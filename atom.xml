<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Scarletsky</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://scarletsky.github.io/"/>
  <updated>2017-05-30T15:02:33.000Z</updated>
  <id>http://scarletsky.github.io/</id>
  
  <author>
    <name>Scarletsky</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>「译」追赶时髦的技术</title>
    <link href="http://scarletsky.github.io/2017/05/25/chasing-the-shiny-and-new-in-software/"/>
    <id>http://scarletsky.github.io/2017/05/25/chasing-the-shiny-and-new-in-software/</id>
    <published>2017-05-25T00:32:09.000Z</published>
    <updated>2017-05-30T15:02:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 Web 开发领域，我们会经常看到有人讨论当前最好的框架或编程语言。<a href="https://www.scribd.com/" target="_blank" rel="external">Scribd</a> 的联合创始人 Jared Friedman 在 2015 年的时候专门写了<a href="http://blog.jaredfriedman.com/2015/09/15/why-i-wouldnt-use-rails-for-a-new-company/" target="_blank" rel="external">一篇文章</a>推荐创业公司使用 Node.js 代替 Rails。</p>
<p>他有以下观点：</p>
<ul>
<li>Rails 很慢。</li>
<li>Hack academy 的毕业生都在用 Rails，让高级工程师贬值，并减少了它们的未来前景。</li>
<li>一个创业公司应该使用工程师想用的技术，这样能保证应用程序的质量。</li>
<li>在 Scribd，他们这几年已经把技术栈从 Prototype 过渡到 jQuery，再到 CoffeeScript，再到 Angular，再到 React。</li>
</ul>
<p>Node.js 对于创业公司来说是一个很好的选择，但他提到的两点让我很困惑。<br>首先，一个创业公司的工程师要明白哪个技术会在几年内流行并且让技术栈不会过时。<br>然后，优秀的软件工程师会被一个创业公司的技术栈吸引，而不是它们要解决的技术难题。<br>在过去，我听说过一些不好的传闻：</p>
<ul>
<li>创业公司里的开发者不会接受用 ES5 的 Offer(那时候 CoffeeScript 刚出来)。</li>
<li>在 Mongo 发布不久，工程师倾向在生产环境下用 Mongo 代替 Postgres。</li>
<li>工程师们都渴望用最新的前端框架来不断重构他们的项目。</li>
</ul>
<p>我担心有些程序员(和他们的雇主)有这种倾向，也就是把注意力都放在迁移技术栈上。他们选择公司的时候会基于框架，想在工作中用上最先的技术，而不是最适合的工具。他们把时间都花在新的库和框架上，而不是用来提升自己的核心技术能力。我把他们称为「技术栈追逐者」—— 那些把新技术(或者他们最喜欢的技术)都用在创业公司的技术栈上，但对核心输出(用户体验，团队生产力)提升有限的人。</p>
<h2 id="「现代化」的-Web-开发"><a href="#「现代化」的-Web-开发" class="headerlink" title="「现代化」的 Web 开发"></a>「现代化」的 Web 开发</h2><p>很同情在 <a href="https://news.ycombinator.com/" target="_blank" rel="external">Hacker News</a> 上现代的 Web 或者移动开发者。作为一个全栈工程师，在 2012 年你们开发网站时后端用 Ruby/Rails ，前端用 Backbone/CoffeeScript/Underscore，部署时用 Capistrano (或者是和 Python 的 analog 相关的工具)。到了 2013 年，你们后端迁移到 Node/Express/Mongo，前端迁移到 Grunt/Ember。到了 2014 年，你们已经把全站切换到 MEAN 技术栈了，但要试验 Koa 和 Go(在 Express 的核心开发者<a href="https://medium.com/@tjholowaychuk/farewell-node-js-4ba9e7f3e52b" target="_blank" rel="external">跑路</a>)。在 2015 年，你们在前端开始用 Gulp/ES2015/React，后端用 Express/Go，用 React Native 来替代原生开发语言，并且用 Docker 慢慢地把系统迁移到微服务架构。不久之后，你将会迁移到 Phoenix，如果 Angular 2 更好的话，你们会迁移过去。或许以后 Go 能用来开发安卓，Swift 可能会适合你们的技术栈(虽然我显然是夸张了，但在 Hacker News 的头条上讨论什么更流行是很正常的表现)。</p>
<p>如果考虑下面提到的这些原因，那么这种行为是可以被理解的，现代的 Web 开发工程师要获得一份更好的工作，他们要更加「时尚」。雇主用框架或者编程语言来筛选雇员，而不是测试他们的思考方式和技能。然而，雇主并没有意识到，优秀的开发者可以在几周，甚至几天就能掌握很多语言或者框架。有时候趋势是无法阻止的：Swift 正在替代 Objective C，世界向着轻量的方向发展，后端需要变得更轻量，前端要更多的响应式。通常，这种变化都会带来巨大的好处：生产力有本质上的提升，用户功能更加容易实现。另外，对于中小型企业来说，这些改变会关系到企业的存亡。</p>
<p>我们可以用在创业公司里的现代的 Web 或移动开发者与我们的计算机科学家作为对比。我有一个朋友在一家顶级的科技公司做计算机神经系统科学家，跟大部分技术人一样，他的世界几个月就会发生变化 —— 得益于计算能力，脑成像和深度学习算法的快速发展。但他的编程工具几乎没发生什么变化。公平来讲，只有 C++ 从 11 迁移到 14 引起了一点担心。其他的变化还有分布式系统，键值存储和其他外部服务，但这些用的都是稳定的 API。他大部分的时间都花在架构和算法上，不会花时间去重写功能相似的代码或学习类库。</p>
<h2 id="选择工具"><a href="#选择工具" class="headerlink" title="选择工具"></a>选择工具</h2><p>人们可能会建议创业公司去选择现代化的技术栈，因为这是招聘优秀工程师的一个很关键的工具。根据我自己的观察，优秀的工程师关注的是其他方面，他们最关注的是解决感兴趣的问题，和有趣的同事一起解决问题。吸引优秀的人(工程师或者其他岗位)的附加条件是要引领时代发展和肩负伟大的使命。</p>
<p>我并不是在抱怨技术发展太快，也不是说我们都应该用汇编语言或者 C++ 或者 Ruby。软件工程师们清楚他们的目标 —— 领域发展太快，他们得花精力在上面，因为那会影响线上的数十亿人。但我想说的是，你们需要挑选新框架，编程语言，或者类库的能力，然后和你们周围那些经验丰富的工程师一起，提高你们的生产力。除此之外，你们要深刻理解编程语言的多样性，了解各种语言间的差异，不要只关注当前流行的那个(同样，不要盲目地选择框架)。</p>
<p>对于创业公司，Paul Graham 在 2013 年的时候被问到关于理想的编程语言：「我们有些创业公司用 PHP 来写他们的产品 —— 那让我有点担忧。但这并不像其他事情那么值得我担忧。」<br>Github 的技术人员 Sam Lambert 在一次的采访中说第一次面试时，CTO 对他说 Github 大量使用 Rails，C，和 Bash 脚本，他非常惊讶：「随着面试进行，他向我透露那实际上是一群非常务实的黑客在 hack Ruby，hack C，把他们的时间都花在感兴趣的事情上，使用一个稳定的技术栈，好过追逐最新最酷炫的技术。」<br>Github 的方式在我看来是 Web 和移动开发者的一个合理的平衡：广泛地探索工具，但按照实际需求来选择工具来解决你们要面临的问题。</p>
<p>我担心的是某些开发者，特别是在他们早期的职业生涯当中，有这么一种想法：一个创业公司的工程师并不是专门解决问题的，也不是计算机科学家，只是一个荣誉查找表 —— 他们的任务是每几个月就去研究新的类库/框架/编程语言，来获取有限的提升。这使我们这些早期的工程师贬值，因为我们的工作是创造人们想要的东西，关注感兴趣的技术难题，快速的用代码实现。</p>
<p>因此，务必在你的业余时间中才去实验新技术。只有当切换技术栈有非常巨大的提升的情况下，才在生产环境下切换编程语言/框架，同时要好好想想切换获得了什么优势。警惕那些不考虑新技术对团队的影响，却不断为新技术欢呼的人。你应该把时间花在学习概念，解决技术难题或用户反馈上。如果你有合适的应用程序，而你现在又在选择框架来实现它，那么你的技术选型会有一定的灵活性，但要经过持久的努力才能适应市场。</p>
<p>任何一天打开 <a href="https://news.ycombinator.com/" target="_blank" rel="external">Hacker News</a>，你都能看到有帖子诱惑你去用某个框架、语言、类库或者服务来构建应用程序。有些工具拥有改变游戏规则的能力，其他的却只有细微的差异，但要精通它们都是需要时间的。有些工具会大力宣传它们的特点，并嘲笑你所学的技能 —— 但他们却需要你的技能和注意力，这样才能与现在有的技术竞争。你会怎么选择？</p>
<p>虽然本文是用 MacVim 7.4 写的，但我觉得应该用 Atom，或者至少是 Neovim。</p>
<h2 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h2><p><a href="https://www.nemil.com/musings/shinyandnew.html?utm_source=wanqu.co&amp;utm_campaign=Wanqu+Daily&amp;utm_medium=website" target="_blank" rel="external">Chasing the Shiny and New in Software</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Web 开发领域，我们会经常看到有人讨论当前最好的框架或编程语言。&lt;a href=&quot;https://www.scribd.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Scribd&lt;/a&gt; 的联合创始人 Jared Friedman 在 20
    
    </summary>
    
      <category term="tech" scheme="http://scarletsky.github.io/categories/tech/"/>
    
    
  </entry>
  
  <entry>
    <title>PostgreSQL 中的客户端认证</title>
    <link href="http://scarletsky.github.io/2017/04/26/client-authentication-in-postgresql/"/>
    <id>http://scarletsky.github.io/2017/04/26/client-authentication-in-postgresql/</id>
    <published>2017-04-26T00:05:06.000Z</published>
    <updated>2017-04-30T07:18:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>当客户端与数据库服务器连接时，它需要指定用哪个数据库用户的身份来连接。<br>PostgreSQL 为我们提供了很多种客户端认证的方式，我们可以根据自己的需要来选择认证方式。</p>
<h2 id="psql"><a href="#psql" class="headerlink" title="psql"></a>psql</h2><p><code>psql</code> 是 PostgreSQL 的客户端程序，要连接 PostgreSQL 数据库，我们需要指定以下内容：</p>
<ul>
<li><code>-d</code> or <code>--dbname</code> 数据库名<ul>
<li>默认情况下是连接与当前操作系统用户名字相同的数据库。</li>
<li>如果该数据库不存在，会报 psql: FATAL:  database “root” does not exist。</li>
</ul>
</li>
<li><code>-h</code> or <code>--host</code> 主机名<ul>
<li>默认情况下 psql 会通过 Unix socket 连接数据库。</li>
<li>如果没有 Unix socket，那么会以 TCP/IP 连接到 localhost。</li>
<li>如果需要通过 TCP/IP 连接到数据库，那么就需要指定主机名。</li>
</ul>
</li>
<li><code>-p</code> or <code>--port</code> 端口号<ul>
<li>默认情况下是 5432 端口。</li>
</ul>
</li>
<li><code>-U</code> or <code>--username</code> 用户名<ul>
<li>默认情况下是用当前操作系统用户名去连接数据库。</li>
<li>如果该用户不存在，会报 psql: FATAL:  role “root” does not exist。</li>
</ul>
</li>
</ul>
<p>我们也可以用 URI 的方式连接数据库：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">psql postgresql://dbmaster:5433/mydb?sslmode=require</div></pre></td></tr></table></figure>
<h2 id="常见情况"><a href="#常见情况" class="headerlink" title="常见情况"></a>常见情况</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ psql</div><div class="line">postgres=# CREATE USER test WITH PASSWORD &apos;123456&apos;;</div><div class="line">postgres=# CREATE DATABASE test OWNER test;</div><div class="line">postgres=# \q</div><div class="line"></div><div class="line">$ psql -U test</div><div class="line">psql: FATAL:  Peer authentication failed for user &quot;test&quot;</div><div class="line">$ psql -U test -h 127.0.0.1</div><div class="line">psql: FATAL:  Ident authentication failed for user &quot;test&quot;</div></pre></td></tr></table></figure>
<p>相信每个在生产环境中使用 PostgreSQL 的人都折腾过客户端认证的问题。<br>明明用户名和密码都正确，而且用户也是数据库的拥有者，为什么 PostgreSQL 会禁止访问？<br>这通常是因为 <code>pg_hba.conf</code> 没有配置好。</p>
<h2 id="pg-hba-conf"><a href="#pg-hba-conf" class="headerlink" title="pg_hba.conf"></a>pg_hba.conf</h2><h3 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h3><p><code>pg_hba.conf</code> 是 PostgreSQL 客户端认证的配置文件 (hba 是 host-based authentication 的缩写)，它位于 PostgreSQL 的配置目录下，通常是 <code>/usr/local/pgsql/data</code> 或者 <code>/var/lib/pgsql/data</code>。<br>如果两个位置都找不到，但可以连接到数据库，可以直接在 psql shell 里面输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">postgres=# SHOW hba_file;</div><div class="line">              hba_file</div><div class="line">-------------------------------------</div><div class="line"> /usr/local/var/postgres/pg_hba.conf</div></pre></td></tr></table></figure>
<p>如果没有连接数据库的权限，可以尝试在终端中输入 <code>ps aux | grep postgres</code>，它会输出和 PostgreSQL 相关的进程，找到类似下面的进程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># ps aux | grep postgres</div><div class="line">root   3815  0.0  0.0  10772   920 pts/1    S+   00:34   0:00 grep --color=auto postgres</div><div class="line">postgres 24819  0.0  1.9 238588 20068 ?        S    Apr25   0:01 /usr/bin/postgres -D /var/lib/pgsql/data</div><div class="line">....</div></pre></td></tr></table></figure>
<p>其中 -D 后面的就是该目录的位置了。</p>
<h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p>找到 <code>pg_hba.conf</code> 的位置之后，我们可以查看里面的内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># cat pg_hba.conf</div><div class="line">...</div><div class="line"># TYPE  DATABASE        USER            ADDRESS                 METHOD</div><div class="line">local   all             all                                     peer</div><div class="line">host    all             all             127.0.0.1/32            ident</div><div class="line">host    all             all             ::1/128                 ident</div></pre></td></tr></table></figure>
<p>从内容可以看出，<code>pg_hba.conf</code> 是以行为单位来配置的，每一行包含了以下内容：</p>
<ul>
<li><p><code>TYPE</code> 连接类型，表示允许用哪些方式连接数据库，它允许以下几个值：</p>
<ul>
<li><code>local</code> 通过 Unix socket 的方式连接。</li>
<li><code>host</code> 通过 TCP/IP 的方式连接，它能匹配 SSL 和 non-SSL 连接。</li>
<li><code>hostssl</code> 只允许 SSL 连接。</li>
<li><code>hostnossl</code> 只允许 non-SSL 连接。</li>
</ul>
</li>
<li><p><code>DATABASE</code> 可连接的数据库，它有以下几个特殊值：</p>
<ul>
<li><code>all</code> 匹配所有数据库。</li>
<li><code>sameuser</code> 可连接和用户名相同的数据库。</li>
<li><code>samerole</code> 可连接和角色名相同的数据库。</li>
<li><code>replication</code> 允许复制连接，用于集群环境下的数据库同步。<br>除了上面这些特殊值之外，我们可以写特定的数据库，可以用逗号 (,) 来分割多个数据库。</li>
</ul>
</li>
<li><p><code>USER</code> 可连接数据库的用户，值有三种写法：</p>
<ul>
<li><code>all</code> 匹配所有用户。</li>
<li>特定数据库用户名。</li>
<li>特定数据库用户组，需要在前面加上 <code>+</code> (如：<code>+admin</code>)。</li>
</ul>
</li>
<li><p><code>ADDRESS</code> 可连接数据库的地址，有以下几种形式：</p>
<ul>
<li><code>all</code> 匹配所有 IP 地址。</li>
<li><code>samehost</code> 匹配该服务器的 IP 地址。</li>
<li><code>samenet</code> 匹配该服务器子网下的 IP 地址。</li>
<li>ipaddress/netmask (如：172.20.143.89/32)，支持 IPv4 与 IPv6。</li>
<li>如果上面几种形式都匹配不上，就会被当成是 hostname。<br><strong>注意: 只有 host, hostssl, hostnossl 会应用个字段。</strong></li>
</ul>
</li>
<li><p><code>METHOD</code> 连接数据库时的认证方式，常见的有几个特殊值：</p>
<ul>
<li><code>trust</code> 无条件通过认证。</li>
<li><code>reject</code> 无条件拒绝认证。</li>
<li><code>md5</code> 用 md5 加密密码进行认证。</li>
<li><code>password</code> 用明文密码进行认证，不建议在不信任的网络中使用。</li>
<li><code>ident</code> 从一个 ident 服务器 (RFC1413) 获得客户端的操作系统用户名并且用它作为被允许的数据库用户名来认证，只能用在 TCP/IP 的类型中 (即 host, hostssl, hostnossl)。</li>
<li><code>peer</code> 从内核获得客户端的操作系统用户名并把它用作被允许的数据库用户名来认证，只能用于本地连接 (即 local)。</li>
<li>其他特殊值可以在 <a href="https://www.postgresql.org/docs/9.6/static/auth-pg-hba-conf.html" target="_blank" rel="external">官方文档</a> 中查阅。<br><strong>简单来说，ident 和 peer 都要求客户端操作系统中存在对应的用户。</strong><br><strong>注意: 上面列举的只有 md5 和 password 是需要密码的，其他方式都不需要输入密码认证。</strong></li>
</ul>
</li>
</ul>
<p>了解完这些字段之后，我们可以看看 <code>pg_hba.conf</code> 初始化的内容了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">local   all             all                                     peer</div><div class="line"># 表示本机上的所有用户可以以 Unix socket 的方式连接数据库。</div><div class="line">host    all             all             127.0.0.1/32            ident</div><div class="line"># 同上，但只允许 127.0.0.1/32 (IPv4) 这个 IP 连接数据库。</div><div class="line">host    all             all             ::1/128                 ident</div><div class="line"># 同上，但只允许 ::1/128 (IPv6) 这个 IP 连接数据库。</div></pre></td></tr></table></figure>
<h2 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h2><p>在文章开头，我们看见过两种错误，分别是 Peer authentication failed 和 Ident authentication failed。<br>这是因为 <code>pg_hba.conf</code> 中限定了认证方式是 <code>peer</code> 和 <code>ident</code>。<br>要让我们的 test 用户连接到数据库，我们有以下选择：</p>
<ul>
<li>让 test 用户通过 <code>peer</code> 和 <code>ident</code> 认证</li>
<li>修改 <code>pg_hba.conf</code> 的认证方式</li>
</ul>
<h3 id="让用户通过-peer-和-ident-认证"><a href="#让用户通过-peer-和-ident-认证" class="headerlink" title="让用户通过 peer 和 ident 认证"></a>让用户通过 peer 和 ident 认证</h3><p>从上面可以知道，要让用户通过 peer 和 ident 认证，我们需要在操作系统中创建对应的用户。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ sudo su -</div><div class="line"># useradd test</div><div class="line"># psql -U test</div><div class="line">psql: FATAL:  Peer authentication failed for user &quot;test&quot;</div><div class="line"># psql -U test -h 127.0.0.1</div><div class="line">psql: FATAL:  Ident authentication failed for user &quot;test&quot;</div><div class="line"># su - test</div><div class="line">$ psql</div><div class="line">test=&gt;</div></pre></td></tr></table></figure>
<p>如果使用了 ident 的方式进行认证，而客户端的操作系统中没有 ident 服务器，那么客户端的操作系统中需要先安装 ident 服务器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># su - test</div><div class="line">$ psql -U test -h 127.0.0.1</div><div class="line">psql: FATAL:  Ident authentication failed for user &quot;test&quot;</div><div class="line"></div><div class="line">$ dnf install oidentd</div><div class="line">$ systemctl enable oidentd</div><div class="line">$ systemctl start oidentd</div><div class="line"></div><div class="line">$ psql -U test -h 127.0.0.1</div><div class="line">test=&gt;</div></pre></td></tr></table></figure>
<h3 id="修改-pg-hba-conf"><a href="#修改-pg-hba-conf" class="headerlink" title="修改 pg_hba.conf"></a>修改 pg_hba.conf</h3><p>打开 <code>pg_hba.conf</code>，把规则中的 ident 修改成 md5，即：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">host    all             all             127.0.0.1/32            md5</div><div class="line">host    all             all             ::1/128                 md5</div></pre></td></tr></table></figure>
<p>然后重启 PostgreSQL 服务器即可生效。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ vim /var/lib/pgsql/data/pg_hba.conf</div><div class="line">$ systemctl restart postgresql</div><div class="line">$ psql -U test -h 127.0.0.1</div><div class="line">Password for user test:</div><div class="line">test=&gt;</div></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.postgresql.org/docs/9.6/static/app-psql.html" target="_blank" rel="external">https://www.postgresql.org/docs/9.6/static/app-psql.html</a><br><a href="https://www.postgresql.org/docs/9.6/static/client-authentication.html" target="_blank" rel="external">https://www.postgresql.org/docs/9.6/static/client-authentication.html</a><br><a href="https://www.postgresql.org/docs/9.6/static/auth-methods.html" target="_blank" rel="external">https://www.postgresql.org/docs/9.6/static/auth-methods.html</a><br><a href="https://www.postgresql.org/docs/9.6/static/creating-cluster.html" target="_blank" rel="external">https://www.postgresql.org/docs/9.6/static/creating-cluster.html</a><br><a href="http://www.davidpashley.com/articles/postgresql-user-administration/" target="_blank" rel="external">http://www.davidpashley.com/articles/postgresql-user-administration/</a><br><a href="http://stackoverflow.com/questions/14025972/postgresql-how-to-find-pg-hba-conf-file-using-mac-os-x" target="_blank" rel="external">http://stackoverflow.com/questions/14025972/postgresql-how-to-find-pg-hba-conf-file-using-mac-os-x</a><br><a href="http://stackoverflow.com/questions/2942485/psql-fatal-ident-authentication-failed-for-user-postgres" target="_blank" rel="external">http://stackoverflow.com/questions/2942485/psql-fatal-ident-authentication-failed-for-user-postgres</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;当客户端与数据库服务器连接时，它需要指定用哪个数据库用户的身份来连接。&lt;br&gt;PostgreSQL 为我们提供了很多种客户端认证的方式，我们
    
    </summary>
    
    
      <category term="database, postgresql" scheme="http://scarletsky.github.io/tags/database-postgresql/"/>
    
  </entry>
  
  <entry>
    <title>PostgreSQL 学习笔记</title>
    <link href="http://scarletsky.github.io/2017/03/15/notes-of-postgresql/"/>
    <id>http://scarletsky.github.io/2017/03/15/notes-of-postgresql/</id>
    <published>2017-03-15T13:57:28.000Z</published>
    <updated>2017-03-30T13:56:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>PostgreSQL 是世界上功能最强大的关系型数据库，除了标准的 SQL 的支持外，还有丰富的特性，可以通过扩展来增强数据库的能力。<br>本文是我学习 PostgreSQL 过程中的一些总结。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="macOS"><a href="#macOS" class="headerlink" title="macOS"></a>macOS</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">brew update</div><div class="line">brew install postgresql</div></pre></td></tr></table></figure>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul>
<li><code>\?</code> 显示帮助信息</li>
<li><code>\l</code> 列出所有数据库，相当于 <code>show databases</code></li>
<li><code>\c &lt;database_name&gt;</code> 连接指定的数据库，相当于 <code>use &lt;database_name&gt;</code></li>
<li><code>\dt</code> 列出数据库中所有的表，相当于 <code>show tables</code></li>
<li><code>\ds</code> 列出数据库中所有序列</li>
<li><code>\d &lt;table_name&gt;</code> 显示该表的详细信息</li>
<li><code>\password &lt;username&gt;</code> 修改指定用户的密码</li>
<li><code>\dx</code> 列出数据库已使用的扩展</li>
<li><code>\x</code> 开启/关闭展开显示，当 <code>select</code> 的输出结果太长时，可以试试这个模式</li>
</ul>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>我们知道，PostgreSQL 有非常丰富的扩展供我们使用，下面列举一些常见的扩展：</p>
<h3 id="uuid-ossp"><a href="#uuid-ossp" class="headerlink" title="uuid-ossp"></a>uuid-ossp</h3><p>该模块提供了一些函数来生成 UUID。如 <code>uuid_generate_v1</code>, <code>uuid_generate_v4</code> 等。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> EXTENSION <span class="string">"uuid-ossp"</span>;</div><div class="line"><span class="keyword">SELECT</span> uuid_generate_v4();</div><div class="line">           uuid_generate_v4</div><div class="line"><span class="comment">--------------------------------------</span></div><div class="line"> cc230056-ed05-4bcf-a12f-1611728ac199</div></pre></td></tr></table></figure>
<p>从<a href="http://www.postgres.cn/docs/9.4/uuid-ossp.html" target="_blank" rel="external">官网</a>上了解到，如果我们只需要生成 UUID (v4)，那么可以考虑使用 <code>pgcrypto</code> 模块。</p>
<h3 id="pgcrypto"><a href="#pgcrypto" class="headerlink" title="pgcrypto"></a>pgcrypto</h3><p>该模块提供了一些加密的函数，其中 <code>gen_random_uuid</code> 这个函数可以用来生成 UUID。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> EXTENSION <span class="string">"pgcrypto"</span>;</div><div class="line"><span class="keyword">SELECT</span> gen_random_uuid();</div><div class="line">           gen_random_uuid</div><div class="line"><span class="comment">--------------------------------------</span></div><div class="line"> f8ea5410-cac7-4811-bfbd-5e0b8d0a0cc4</div></pre></td></tr></table></figure>
<h3 id="hstore"><a href="#hstore" class="headerlink" title="hstore"></a>hstore</h3><p>该模块为 PostgreSQL 提供存储 Key/Value 数据的功能，你可以定义 hstore 数据列来存储这样的数据，并可对这些数据进行分组、排序和唯一检索的查询。</p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">CREATE EXTENSION "hstore";</div><div class="line">SELECT 'a=&gt;1, b=&gt;2'::hstore;</div><div class="line">       hstore</div><div class="line">--------------------</div><div class="line"> "a"=&gt;"1", "b"=&gt;"2"</div></pre></td></tr></table></figure>
<p>对于 hstore 的增删查改操作，我们可以用如下的操作：</p>
<ul>
<li><code>hstore -&gt; text</code> 获取 hstore 中指定的 key。</li>
<li><code>hstore || hstore</code> 合并两个 hstore，常用于更新操作。</li>
<li><code>delete(hstore, text)</code> 删除 hstore 中指定的 key。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> testhstore (<span class="keyword">id</span> <span class="built_in">SERIAL</span>, <span class="keyword">value</span> hstore);</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> testhstore (<span class="keyword">value</span>) <span class="keyword">VALUES</span> (<span class="string">'name=&gt;smallfish, age=&gt;29'</span>::hstore);</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> testhstore (<span class="keyword">value</span>) <span class="keyword">VALUES</span> (<span class="string">'name=&gt;nnfish, age=&gt;20'</span>::hstore);</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> testhstore (<span class="keyword">value</span>) <span class="keyword">VALUES</span> (<span class="string">'name=&gt;aaa, age=&gt;30, addr=&gt;China'</span>::hstore);</div><div class="line"></div><div class="line"><span class="comment">-- 查询 key</span></div><div class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, <span class="keyword">value</span>-&gt;<span class="string">'name'</span> <span class="keyword">AS</span> <span class="keyword">name</span> <span class="keyword">FROM</span> testhstore;</div><div class="line"> id |   name</div><div class="line"><span class="comment">----+-----------</span></div><div class="line">  1 | smallfish</div><div class="line">  2 | nnfish</div><div class="line">  3 | aaa</div><div class="line">(3 rows)</div><div class="line"><span class="comment">-- 更新 key</span></div><div class="line"><span class="keyword">UPDATE</span> testhstore <span class="keyword">SET</span> <span class="keyword">value</span> = <span class="keyword">value</span> || (<span class="string">'addr=&gt;Shanghai'</span>) <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">2</span>;</div><div class="line"><span class="comment">-- 删除 key</span></div><div class="line"><span class="keyword">UPDATE</span> testhstore <span class="keyword">SET</span> <span class="keyword">value</span> = <span class="keyword">delete</span>(<span class="keyword">value</span>, <span class="string">'addr'</span>) <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</div></pre></td></tr></table></figure>
<h3 id="PostGIS"><a href="#PostGIS" class="headerlink" title="PostGIS"></a>PostGIS</h3><p>PostGIS 在对象关系型数据库PostgreSQL上增加了存储管理空间数据的能力，相当于Oracle的spatial部分。PostGIS最大的特点是符合并且实现了OpenGIS的一些规范，是最著名的开源GIS数据库。</p>
<h3 id="PostPic"><a href="#PostPic" class="headerlink" title="PostPic"></a>PostPic</h3><p>PostPic 用来在数据库内进行图像处理，PostPic 为 SQL 增加了 image 类型，还包含很多相关的函数用来处理图片以及从图片中抽取对应的属性。</p>
<h2 id="JSON-JSONB"><a href="#JSON-JSONB" class="headerlink" title="JSON / JSONB"></a>JSON / JSONB</h2><p>JSON 类型是在 PostgreSQL 9.2 版本中加入的，而 JSONB 则是在 9.4 版本中加入的。<br>两者的区别在于：JSON 是纯文本，而 JSONB 则是二进制。<br>由于 JSON 存储的是未经处理过的 JSON 字符串，不需要进行解析，而 JSONB 插入时需要进行解析，因此在插入速度上 JSON 会比 JSONB 快，但在查询时，JSONB 会比 JSON 快。</p>
<p>因此，如果我们的应用需要频繁操作 JSON 的话，用 JSONB 会比较合适；相反，如果只是需要存储的话，用 JSON 会比较合适。</p>
<p>下面是一些常用的 JSON / JSONB 的操作：</p>
<ul>
<li><code>json -&gt; int</code> 根据指定索引获取 JSON 数组中的元素</li>
<li><code>json -&gt; text</code> 获取 JSON 中指定字段的值</li>
<li><code>json #&gt; array</code> 获取 JSON 中指定路径的值</li>
</ul>
<p>需要注意的是，上面三种操作都是返回 <code>JSON(B)</code> 类型的结果，有些情况下我们需要把结果转换成字符串之后才能进行比较。<br>这时候就需要在上面几个操作符改成 <code>-&gt;&gt;</code>, <code>#&gt;&gt;</code>，这样返回的结果就是 <code>text</code> 类型，可以直接进行比较了。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">SELECT</span></div><div class="line">  pg_typeof(<span class="string">'&#123; "name": "john", "age": 30, "addr": "shanghai" &#125;'</span>::<span class="keyword">json</span> -&gt; <span class="string">'age'</span>),</div><div class="line">  pg_typeof(<span class="string">'&#123; "name": "john", "age": 30, "addr": "shanghai" &#125;'</span>::<span class="keyword">json</span> -&gt;&gt; <span class="string">'age'</span>);</div><div class="line"></div><div class="line"> pg_typeof | pg_typeof</div><div class="line"><span class="comment">-----------+-----------</span></div><div class="line"> json      | text</div></pre></td></tr></table></figure>
<p>看看下面的例子：</p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">CREATE TABLE testjson (id SERIAL, value json);</div><div class="line">INSERT INTO testjson (value) values ('&#123; "name": "john", "age": 30, "addr": "shanghai" &#125;');</div><div class="line">INSERT INTO testjson (value) values ('&#123; "name": "lucy", "age": 20, "addr": "guangzhou" &#125;');</div><div class="line">INSERT INTO testjson (value) values ('&#123; "name": "tim", "age": 24, "addr": "beijing", "books": [1,2,3,4,5] &#125;');</div><div class="line"></div><div class="line">-- 根据指定 key 查询</div><div class="line">SELECT * FROM testjson WHERE value -&gt;&gt; 'age' &gt; '20';</div><div class="line"></div><div class="line"> id |                                 value</div><div class="line">----+-----------------------------------------------------------------------</div><div class="line">  1 | &#123; "name": "john", "age": 30, "addr": "shanghai" &#125;</div><div class="line">  3 | &#123; "name": "tim", "age": 24, "addr": "beijing", "books": [1,2,3,4,5] &#125;</div><div class="line"></div><div class="line">-- 根据指定路径查询</div><div class="line">SELECT * FROM testjson WHERE value #&gt;&gt; '&#123;books, 3&#125;' = '4';</div><div class="line"> id |                                 value</div><div class="line">----+-----------------------------------------------------------------------</div><div class="line">  3 | &#123; "name": "tim", "age": 24, "addr": "beijing", "books": [1,2,3,4,5] &#125;</div></pre></td></tr></table></figure>
<p>由于 JSON 是纯文本，因此对其进行更新操作只是相当于操作字符串，如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">UPDATE</span> testjson <span class="keyword">SET</span> <span class="keyword">value</span> = <span class="keyword">replace</span>(<span class="keyword">value</span>::<span class="built_in">text</span>, <span class="string">'"john"'</span>, <span class="string">'"mark"'</span>)::<span class="keyword">json</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</div></pre></td></tr></table></figure>
<p>这种方式相当不友好，因此，如果需要经常操作 JSON 的话，建议使用 JSONB 类型，它提供了多种操作方式。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="comment">-- for JSONB</span></div><div class="line"><span class="comment">-- 根据指定字段更新</span></div><div class="line"><span class="keyword">UPDATE</span> testjsonb <span class="keyword">SET</span> <span class="keyword">value</span> = jsonb_set(<span class="keyword">value</span>, <span class="string">'&#123;name&#125;'</span>, <span class="string">'mark'</span>) <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</div><div class="line"><span class="comment">-- 根据指定路径更新</span></div><div class="line"><span class="keyword">UPDATE</span> testjsonb <span class="keyword">SET</span> <span class="keyword">value</span> = jsonb_set(<span class="keyword">value</span>, <span class="string">'&#123;books, 3&#125;'</span>, <span class="string">'10'</span>) <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</div><div class="line"><span class="comment">-- 移除 age 字段</span></div><div class="line"><span class="keyword">UPDATE</span> testjsonb <span class="keyword">SET</span> <span class="keyword">value</span> = <span class="keyword">value</span> - <span class="string">'age'</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">2</span>;</div></pre></td></tr></table></figure>
<h2 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h2><h3 id="macOS-1"><a href="#macOS-1" class="headerlink" title="macOS"></a>macOS</h3><ul>
<li><p>停止 PostgreSQL 服务器</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">brew services stop postgresql</div></pre></td></tr></table></figure>
</li>
<li><p>升级 PostgreSQL</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">brew update &amp;&amp; brew upgrade postgresql</div></pre></td></tr></table></figure>
</li>
<li><p>为新版 PostgreSQL 创建数据库</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">initdb /usr/local/var/postgres9.6.2 -E utf8</div></pre></td></tr></table></figure>
</li>
<li><p>迁移数据</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">pg_upgrade \</div><div class="line">  -d /usr/local/var/postgres \</div><div class="line">  -D /usr/local/var/postgres9.6.2 \</div><div class="line">  -b /usr/local/Cellar/postgresql/9.5/bin/ \</div><div class="line">  -B /usr/local/Cellar/postgresql/9.6.2/bin/ \</div><div class="line">  -v</div></pre></td></tr></table></figure>
</li>
<li><p>把新数据库移动到 PostgreSQL 默认的位置</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">mv /usr/local/var/postgres /usr/local/var/postgres9.5</div><div class="line">mv /usr/local/var/postgres9.6.2 /usr/local/var/postgres</div></pre></td></tr></table></figure>
</li>
<li><p>重启 PostgreSQL 服务器</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">brew services start postgresql</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="常见坑"><a href="#常见坑" class="headerlink" title="常见坑"></a>常见坑</h2><h3 id="单引号与双引号"><a href="#单引号与双引号" class="headerlink" title="单引号与双引号"></a>单引号与双引号</h3><p>单引号 (<code>&#39;</code>) 和双引号 (<code>&quot;</code>) 在 PostgreSQL 中有明确的区分，单引号用来引用值 (value)，而双引号用来引用标识符，如字段名，表名等等。<br>因此，下面两段 SQL 会有不同的结果：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="comment">-- 单引号</span></div><div class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> posts <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="string">'ad3eef9a-e081-46a9-9304-4a1d1637e542'</span>;</div><div class="line">                  id</div><div class="line"><span class="comment">--------------------------------------</span></div><div class="line"> ad3eef9a-e081-46a9-9304-4a1d1637e542</div><div class="line">(1 row)</div><div class="line"></div><div class="line"><span class="comment">-- 双引号</span></div><div class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> posts <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="string">"ad3eef9a-e081-46a9-9304-4a1d1637e542"</span>;</div><div class="line">ERROR:  column "ad3eef9a-e081-46a9-9304-4a1d1637e542" does not exist</div><div class="line">LINE 1: <span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> posts <span class="keyword">where</span> <span class="keyword">id</span> = <span class="string">"ad3eef9a-e081-46a9-9304-4a1...</span></div></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.postgres.cn/docs/9.4/index.html" target="_blank" rel="external">http://www.postgres.cn/docs/9.4/index.html</a><br><a href="http://postgresguide.com/" target="_blank" rel="external">http://postgresguide.com/</a><br><a href="http://www.ruanyifeng.com/blog/2013/12/getting_started_with_postgresql.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2013/12/getting_started_with_postgresql.html</a><br><a href="https://hashrocket.com/blog/posts/faster-json-generation-with-postgresql" target="_blank" rel="external">https://hashrocket.com/blog/posts/faster-json-generation-with-postgresql</a><br><a href="https://www.postgresql.org/docs/9.4/static/uuid-ossp.html" target="_blank" rel="external">https://www.postgresql.org/docs/9.4/static/uuid-ossp.html</a><br><a href="https://www.postgresql.org/docs/9.4/static/pgcrypto.html" target="_blank" rel="external">https://www.postgresql.org/docs/9.4/static/pgcrypto.html</a><br><a href="http://www.postgresqltutorial.com/postgresql-hstore/" target="_blank" rel="external">http://www.postgresqltutorial.com/postgresql-hstore/</a><br><a href="https://www.postgresql.org/docs/9.5/static/sql-do.html" target="_blank" rel="external">https://www.postgresql.org/docs/9.5/static/sql-do.html</a><br><a href="https://keita.blog/2016/01/09/homebrew-and-postgresql-9-5/" target="_blank" rel="external">https://keita.blog/2016/01/09/homebrew-and-postgresql-9-5/</a><br><a href="http://www.oschina.net/news/28211/postgresql-most-useful-extensions" target="_blank" rel="external">http://www.oschina.net/news/28211/postgresql-most-useful-extensions</a><br><a href="http://chenxiaoyu.org/2011/02/19/postgresql-key-value-hstore.html" target="_blank" rel="external">http://chenxiaoyu.org/2011/02/19/postgresql-key-value-hstore.html</a><br><a href="https://segmentfault.com/a/1190000002911580" target="_blank" rel="external">https://segmentfault.com/a/1190000002911580</a><br><a href="https://www.citusdata.com/blog/2016/07/14/choosing-nosql-hstore-json-jsonb/" target="_blank" rel="external">https://www.citusdata.com/blog/2016/07/14/choosing-nosql-hstore-json-jsonb/</a><br><a href="http://blog.lerner.co.il/quoting-postgresql/" target="_blank" rel="external">http://blog.lerner.co.il/quoting-postgresql/</a><br><a href="https://wiki.postgresql.org/wiki/Things_to_find_out_about_when_moving_from_MySQL_to_PostgreSQL" target="_blank" rel="external">https://wiki.postgresql.org/wiki/Things_to_find_out_about_when_moving_from_MySQL_to_PostgreSQL</a><br><a href="http://stackoverflow.com/questions/38777535/what-is-the-difference-between-and-in-postgres-sql" target="_blank" rel="external">http://stackoverflow.com/questions/38777535/what-is-the-difference-between-and-in-postgres-sql</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;PostgreSQL 是世界上功能最强大的关系型数据库，除了标准的 SQL 的支持外，还有丰富的特性，可以通过扩展来增强数据库的能力。&lt;br
    
    </summary>
    
      <category term="sql" scheme="http://scarletsky.github.io/categories/sql/"/>
    
    
      <category term="sql" scheme="http://scarletsky.github.io/tags/sql/"/>
    
      <category term="postgresql" scheme="http://scarletsky.github.io/tags/postgresql/"/>
    
  </entry>
  
  <entry>
    <title>如何用 JavaScript 实现 Popover</title>
    <link href="http://scarletsky.github.io/2017/02/18/implement-popover-with-javascript/"/>
    <id>http://scarletsky.github.io/2017/02/18/implement-popover-with-javascript/</id>
    <published>2017-02-18T08:21:21.000Z</published>
    <updated>2017-02-21T16:22:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Popover 是我们日常开发中用得比较多的组件，通常用于给定一个触发元素，当某特定事件 (<code>hover</code>, <code>click</code>等) 在该元素上触发时，弹出相关的菜单供用户选择。</p>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>我们的 Popover 需要实现如下特性：</p>
<ul>
<li>点击触发元素时，Popover 出现/消失</li>
<li>点击 Popover 内部时，Popover 不消失</li>
<li>点击 Popover 外部时(不包含触发元素)，Popover 消失</li>
</ul>
<p>先看如下的 HTML 结构和 CSS 代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"trigger"</span>&gt;</span>click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"popover"</span> <span class="attr">class</span>=<span class="string">"popover"</span>&gt;</span></div><div class="line">    i am popover</div><div class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"hide"</span>&gt;</span>hide popover<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><div class="line"><span class="selector-class">.popover</span> &#123;</div><div class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</div><div class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid black;</div><div class="line">  <span class="attribute">display</span>: none;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.popover</span><span class="selector-class">.show</span> &#123;</div><div class="line">  <span class="attribute">display</span>: block;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是一个基本的 Popover 的 HTML 结构和用来实现出现/消失的 CSS，再添加一些 JavaScript 代码，我们就能实现一个 Popover 了。<br>实现 Popover 中最麻烦的是上面提到的最后一点，即： 如何判断点击事件是发生在 Popover 内部还是外部。<br>对于这个问题，常见的有两种解法：</p>
<ul>
<li>监听 document 中的 click 事件</li>
<li>利用 tabindex + focus + blur</li>
</ul>
<h2 id="监听-document-中的-click-事件"><a href="#监听-document-中的-click-事件" class="headerlink" title="监听 document 中的 click 事件"></a>监听 document 中的 click 事件</h2><p>一种常见的方式是在 <code>document</code> 中添加事件监听器，用 <code>e.target</code> 来判断点击是否发生在 Popover 内部。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> isVisible = <span class="literal">false</span>;</div><div class="line"><span class="keyword">var</span> trigger = <span class="built_in">document</span>.getElementById(<span class="string">'trigger'</span>);</div><div class="line"><span class="keyword">var</span> hide = <span class="built_in">document</span>.getElementById(<span class="string">'hide'</span>);</div><div class="line"><span class="keyword">var</span> popover = <span class="built_in">document</span>.getElementById(<span class="string">'popover'</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">showPopover</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  isVisible = <span class="literal">true</span>;</div><div class="line">  popover.classList.add(<span class="string">'show'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hidePopover</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  isVisible = <span class="literal">false</span>;</div><div class="line">  popover.classList.remove(<span class="string">'show'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">togglePopover</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (isVisible) &#123;</div><div class="line">    hidePopover();</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    showPopover();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">trigger.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</div><div class="line">  e.stopPropagation();</div><div class="line">  togglePopover();</div><div class="line">&#125;);</div><div class="line"></div><div class="line">hide.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</div><div class="line">  hidePopover();</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (isVisible &amp;&amp;</div><div class="line">      e.target !== popover &amp;&amp;</div><div class="line">      e.target.parentElement !== popover</div><div class="line">  ) &#123;</div><div class="line">    hidePopover();</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上面的实现虽然非常简单，但有一点需要注意的：<br>由于我们是在 <code>document</code> 中来监听 <code>click</code> 是否触发在 Popover 外部的，而触发元素也是在 Popover 之外，由事件冒泡的流程可以知道，浏览器会先调用触发元素中的函数，再调用 <code>document</code> 中的函数，这样一来 Popover 就不会显示了。所以我们需要调用 <code>e.stopPropagation</code> 来告诉浏览器不在派发事件。</p>
<h2 id="利用-tabindex-focus-blur"><a href="#利用-tabindex-focus-blur" class="headerlink" title="利用 tabindex + focus + blur"></a>利用 tabindex + focus + blur</h2><p>这种方式是利用 <code>tabindex</code> 让 Popover 能够响应 <code>focus</code> 和 <code>blur</code> 事件。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"trigger"</span>&gt;</span>click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"popover2"</span> <span class="attr">class</span>=<span class="string">"popover"</span> <span class="attr">tabindex</span>=<span class="string">"0"</span>&gt;</span></div><div class="line">    i am popover</div><div class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"close"</span>&gt;</span>close<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><div class="line"><span class="selector-id">#popover2</span> &#123;</div><div class="line">  <span class="attribute">outline</span>: none;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> trigger = <span class="built_in">document</span>.getElementById(<span class="string">'trigger'</span>);</div><div class="line"><span class="keyword">var</span> popover = <span class="built_in">document</span>.getElementById(<span class="string">'popover2'</span>);</div><div class="line"><span class="keyword">var</span> hide = <span class="built_in">document</span>.getElementById(<span class="string">'hide'</span>);</div><div class="line"><span class="keyword">var</span> shouldTriggerBlur = <span class="literal">true</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">showPopover</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  popover.classList.add(<span class="string">'show'</span>);</div><div class="line">  popover.focus();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hidePopover</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  shouldTriggerBlur = <span class="literal">true</span>;</div><div class="line">  popover.classList.remove(<span class="string">'show'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">trigger.addEventListener(<span class="string">'click'</span>, showPopover);</div><div class="line"></div><div class="line">hide.addEventListener(<span class="string">'click'</span>, hidePopover);</div><div class="line"></div><div class="line">popover.addEventListener(<span class="string">'blur'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (shouldTriggerBlur) &#123;</div><div class="line">    hidePopover();</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">popover.addEventListener(<span class="string">'mousedown'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (e.target === hide) &#123;</div><div class="line">    shouldTriggerBlur = <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>当点击触发元素时，调用 Popover 的 <code>focus</code> 方法，这样如果鼠标点击 Popover 外部时，就能自动触发 <code>blur</code> 事件了。<br>有一点是需要注意的：如果 Popover 中有其他可以响应 <code>click</code> 事件的元素 (如 <code>&lt;button /&gt;</code>)，当我们点击这些元素时，会先触发 Popover 的 <code>blur</code> 事件，这时候 Popover 已经隐藏了，那么 Popover 中的 <code>&lt;button /&gt;</code> 自然就点击不到了。<br>因此，上面的例子中，我用了一个 <code>shouldTriggerBlur</code> 变量来判断是否需要触发 <code>blur</code> 事件。</p>
<p>另外，这种实现有一个缺陷：在 Popover 出现后再点击触发元素，Popover 并不会消失。原因和刚才提到的一样，因为 <code>blur</code> 事件比 <code>click</code> 先触发。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Popover 是我们日常开发中用得比较多的组件，通常用于给定一个触发元素，当某特定事件 (&lt;code&gt;hover&lt;/code&gt;, &lt;cod
    
    </summary>
    
      <category term="javascript" scheme="http://scarletsky.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://scarletsky.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>用 JavaScript 构建事件系统</title>
    <link href="http://scarletsky.github.io/2017/01/30/build-your-own-event-system-in-javascript/"/>
    <id>http://scarletsky.github.io/2017/01/30/build-your-own-event-system-in-javascript/</id>
    <published>2017-01-30T00:30:21.000Z</published>
    <updated>2017-01-31T15:48:25.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在组件化开发越来越流行的今天，事件系统演者着非常重要的角色，它经常作为组件间通讯的桥梁。<br>本文将讨论如何用 JavaScript 实现一个简单的事件系统。</p>
<h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><p>我们先回想一下使用事件系统的方式。<br>通常，我们要先通过 <code>on</code> / <code>listen</code> 方法注册为一个事件注册一个回调函数。<br>然后调用 <code>emit</code> / <code>fire</code> 来触发一个事件，该事件对应的回调函数就会一一触发。<br>这样就是我们平常使用的事件系统的工作方式。</p>
<p>事件系统本质上是一个键值对的合集，一个事件名对应多个函数。<br>在 JavaScript 中，我们很容易用一个 <code>Object</code> 来模拟这种行为。如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">ADD_ENTITY</span>: [fn1, fn2, fn3],</div><div class="line">  <span class="attr">REMOVE_ENTITY</span>: [fn4],</div><div class="line">  <span class="attr">UPDATE_ENTITY</span>: [fn5, fn6]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的结构表示有三个事件：<code>ADD_ENTITY</code>, <code>REMOVE_ENTITY</code>, <code>UPDATE_ENTITY</code>，它们对应了一些回调函数。<br>当 <code>ADD_ENTITY</code> 触发的时候，<code>fn1</code>, <code>fn2</code>, <code>fn3</code> 都会依次调用，如此类推。</p>
<h2 id="on-amp-off-amp-emit"><a href="#on-amp-off-amp-emit" class="headerlink" title="on &amp; off &amp; emit"></a>on &amp; off &amp; emit</h2><p>接下来我们将利用上述的结构来实现事件系统。其中最基本的三个操作是：</p>
<ul>
<li><code>on</code> 监听事件</li>
<li><code>off</code> 移除事件</li>
<li><code>emit</code> 触发事件</li>
</ul>
<p>按照上述的结构，我们很容易可以写出如下的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventEmitter</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">this</span>._events = &#123;&#125;;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  on(event, callback) &#123;</div><div class="line">    <span class="keyword">let</span> callbacks = <span class="keyword">this</span>._events[event] || [];</div><div class="line">    callbacks.push(callback);</div><div class="line">    <span class="keyword">this</span>._events[event] = callbacks;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  off(event) &#123;</div><div class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>._events[event]</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  emit(event) &#123;</div><div class="line">    <span class="keyword">let</span> callbacks = <span class="keyword">this</span>._events[event];</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!callbacks || callbacks.length === <span class="number">0</span>) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'You should register listener for event '</span> + event);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> args = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</div><div class="line">    callbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn.apply(<span class="keyword">this</span>, args));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码非常简单，<code>on</code> 和 <code>off</code> 只是在操作 <code>Object</code>，为其添加、更新或删除一些键值对。<br>而 <code>emit</code> 方法只是根据给定的事件名来调用它相关的回调函数。</p>
<p>这样，我们就实现了一个简单的事件系统：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> ee = <span class="keyword">new</span> EventEmitter();</div><div class="line">ee.on(<span class="string">'TEST1'</span>, (x) =&gt; <span class="built_in">console</span>.log(<span class="string">'In test1, x is: '</span>, x));</div><div class="line">ee.on(<span class="string">'TEST2'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'In test2'</span>));</div><div class="line">ee.on(<span class="string">'TEST2'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'In test2 again'</span>));</div><div class="line"></div><div class="line">ee.emit(<span class="string">'TEST1'</span>, <span class="number">1</span>);</div><div class="line"><span class="comment">// In test1, x is:  1</span></div><div class="line"></div><div class="line">ee.emit(<span class="string">'TEST2'</span>);</div><div class="line"><span class="comment">// In test2</span></div><div class="line"><span class="comment">// In test2 again</span></div><div class="line"></div><div class="line">ee.off(<span class="string">'TEST1'</span>);</div><div class="line">ee.off(<span class="string">'TEST2'</span>);</div><div class="line"><span class="built_in">console</span>.log(ee._events);</div><div class="line"><span class="comment">// &#123;&#125;</span></div></pre></td></tr></table></figure>
<h2 id="once"><a href="#once" class="headerlink" title="once"></a>once</h2><p>有些时候，我们需要指定某些回调函数只触发一次。<br>如：当页面加载完成后，执行初始化操作，这个操作就只会执行一次，之后再执行就不会生效。<br>上面的事件系统无法实现这种需求，因为每次触发事件，所有绑定的回调事件都会执行，不存在只执行一次的情况。</p>
<p>其实，我们只需要在执行回调函数后把该函数从列表中移除，就可以实现这种需求。<br>在这之前，我们先想想应该如何存储这些需要移除的函数。<br>存储方式大概有两种，一种是和不需要移除的函数保存在一起，即：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">ADD_ENTITY</span>: [</div><div class="line">    &#123; <span class="attr">callback</span>: fn1, <span class="attr">once</span>: <span class="literal">false</span> &#125;,</div><div class="line">    &#123; <span class="attr">callback</span>: fn2, <span class="attr">once</span>: <span class="literal">true</span> &#125;</div><div class="line">  ],</div><div class="line">  <span class="attr">REMOVE_ENTITY</span>: [</div><div class="line">    &#123; <span class="attr">callback</span>: fn3, <span class="attr">once</span>: <span class="literal">true</span> &#125;</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方式在用 <code>emit</code> 触发事件的时候，需要根据 <code>once</code> 属性来判断是否需要移除该回调函数。<br>另外，这种方式还有一个好处，它能保证回调函数的调用顺序。</p>
<p>另一种方式则是分开存储，通过引入一个新的变量来区分一次生效和多次生效的回调函数，如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">this</span>._events = &#123;</div><div class="line">  <span class="attr">ADD_ENTITY</span>: [fn1, fn2],</div><div class="line">  <span class="attr">REMOVE_ENTITY</span>: [],</div><div class="line">&#125;;</div><div class="line"><span class="keyword">this</span>._onceHandlers = &#123;</div><div class="line">  <span class="attr">ADD_ENTITY</span>: [fn2],</div><div class="line">  <span class="attr">REMOVE_ENTITY</span>: [fn3]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方式把两种函数隔离开，在移除回调函数的时候变得非常方便，直接移除整个 key 即可。</p>
<p>无论我们选择哪种存储方式，对 <code>once</code> 的实现影响都不大，因为只需要对 <code>on</code> 方法做一点修改就可以了。<br>同样，对于删除函数的操作，第一种方式只需要找出 <code>once</code> 为 <code>true</code> 的列表索引，然后根据索引来移除即可，而第二种方式直接删除 key 就可以了。<br>实现起来都比较简单，因此就不给出示例代码了。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://corcoran.io/2013/06/01/building-a-minimal-javascript-event-system/" target="_blank" rel="external">https://corcoran.io/2013/06/01/building-a-minimal-javascript-event-system/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;在组件化开发越来越流行的今天，事件系统演者着非常重要的角色，它经常作为组件间通讯的桥梁。&lt;br&gt;本文将讨论如何用 JavaScript 实现
    
    </summary>
    
      <category term="javascript" scheme="http://scarletsky.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://scarletsky.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Git 中的 ~ 和 ^</title>
    <link href="http://scarletsky.github.io/2016/12/29/tilde-and-caret-in-git/"/>
    <id>http://scarletsky.github.io/2016/12/29/tilde-and-caret-in-git/</id>
    <published>2016-12-29T13:37:31.000Z</published>
    <updated>2016-12-30T12:17:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在使用 Git 的时候，我们经常会看见 <code>~</code> 和 <code>^</code>，如 <code>HEAD~2</code>, <code>HEAD^3</code> 等。<br>初学者经常会对这些符号感到疑惑，本文将讨论这两个符号的用途。</p>
<h2 id="为何需要-和"><a href="#为何需要-和" class="headerlink" title="为何需要 ~ 和 ^"></a>为何需要 ~ 和 ^</h2><p>不知道大家有没体会到，我们经常需要根据一个提交去查找它的祖先提交，如查找 <code>HEAD</code> 的第三个祖先提交。<br>要找到对应的提交，我们可以直接通过 <code>git log</code>，然后手动选中第三个提交。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git <span class="built_in">log</span> --graph --oneline</div><div class="line">* a19bf31 D</div><div class="line">* 85ce81b C</div><div class="line">* 73d1f3b B</div><div class="line">* 078e0e6 A</div><div class="line">...</div></pre></td></tr></table></figure>
<p>然后我们选中 <code>078e0e6 (A)</code> 这个提交，接着进行余下的操作。</p>
<p>这种方式虽然可以实现我们的需求，如果我们想要 <code>HEAD</code> 的第 10 个祖先提交呢？<br>那是要把 log 打印出来，然后一条一条慢慢找吗？这样的话就太低效了。</p>
<p>我们需要有一种方式，根据一个提交快速找到它的祖先提交，因此，我们就需要 <code>~</code> 和 <code>^</code> 这两个符号拉。</p>
<h2 id="的作用"><a href="#的作用" class="headerlink" title="~ 的作用"></a>~ 的作用</h2><p>如果我们想要 <code>HEAD</code> 的第 10 个祖先提交，我们直接用 <code>HEAD~10</code> 就可以了。<br><code>&lt;rev&gt;~&lt;n&gt;</code> 用来表示一个提交的第 n 个祖先提交，如果不指定 n，那么默认为 1。<br>另外，<code>HEAD~~~</code> 和 <code>HEAD~3</code> 是等价的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git rev-parse HEAD</div><div class="line">a19bf31 (D)</div><div class="line"></div><div class="line">$ git rev-parse HEAD~0</div><div class="line">a19bf31 (D)</div><div class="line"></div><div class="line">$ git rev-parse HEAD~</div><div class="line">85ce81b (C)</div><div class="line"></div><div class="line">$ git rev-parse HEAD~1</div><div class="line">85ce81b (C)</div><div class="line"></div><div class="line">$ git rev-parse HEAD~~</div><div class="line">73d1f3b (B)</div><div class="line"></div><div class="line">$ git rev-parse HEAD~3</div><div class="line">078e0e6 (A)</div></pre></td></tr></table></figure>
<h2 id="的作用-1"><a href="#的作用-1" class="headerlink" title="^ 的作用"></a>^ 的作用</h2><p>先看看下面这幅图：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git <span class="built_in">log</span> --graph --oneline</div><div class="line"></div><div class="line">* f44239d D</div><div class="line">*   7a3fb3d C</div><div class="line">|\</div><div class="line">| * 07b920c B</div><div class="line">|/</div><div class="line">* 71bd2cf A</div><div class="line">...</div></pre></td></tr></table></figure>
<p>我们知道，很多情况下一个提交并不是只有一个父提交。<br>就如上图表示那样，<code>7a3fb3d (C)</code> 就有两个父提交：</p>
<ul>
<li><code>07b920c (B)</code></li>
<li><code>71bd2cf (A)</code>。</li>
</ul>
<p>这时候，我们是不能通过 <code>~</code> 去找到 <code>07b920c (B)</code> 这个提交的。<br>如果一个提交有多个父提交，那么 <code>~</code> 只会找第一个父提交。<br>那么我们应该怎么找到 <code>07b920c (B)</code> 呢？<br>答案是：<code>HEAD~^2</code></p>
<p><code>&lt;rev&gt;^&lt;n&gt;</code> 用来表示一个提交的第 n 个父提交，如果不指定 n，那么默认为 1。<br>和 <code>~</code> 不同的是，<code>HEAD^^^</code> 并不等价于 <code>HEAD^3</code>，而是等价与 <code>HEAD^1^1^1</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git rev-parse HEAD~</div><div class="line">7a3fb3d (C)</div><div class="line"></div><div class="line">$ git rev-parse HEAD~^</div><div class="line">71bd2cf (A)</div><div class="line"></div><div class="line">$ git rev-parse HEAD~^0</div><div class="line">7a3fb3d (C)</div><div class="line"></div><div class="line">$ git rev-parse HEAD~^2</div><div class="line">07b920c (B)</div><div class="line"></div><div class="line">$ git rev-parse HEAD~^3</div><div class="line">fatal: ambiguous argument <span class="string">'HEAD~^3'</span>: unknown revision or path not <span class="keyword">in</span> the working tree.</div><div class="line"></div><div class="line">$ git rev-parse HEAD^2</div><div class="line">fatal: ambiguous argument <span class="string">'HEAD^2'</span>: unknown revision or path not <span class="keyword">in</span> the working tree.</div></pre></td></tr></table></figure>
<h2 id="与-的关系"><a href="#与-的关系" class="headerlink" title="~ 与 ^ 的关系"></a>~ 与 ^ 的关系</h2><p>我们知道，<code>~</code> 获取第一个祖先提交，<code>^</code> 可以获取第一个父提交。<br>其实第一个祖先提交就是第一个父提交，反之亦然。<br>因此，当 n 为 1 时，<code>~</code> 和 <code>^</code> 其实是等价的。<br>譬如：<code>HEAD~~~</code> 和 <code>HEAD^^^</code> 是等价的。</p>
<p>最后，引用 <a href="https://www.kernel.org/pub/software/scm/git/docs/git-rev-parse.html" target="_blank" rel="external">kernel.org</a> 中非常形象的一段话：</p>
<blockquote>
<p>Here is an illustration, by Jon Loeliger. Both commit nodes B and C are parents of commit node A. Parent commits are ordered left-to-right.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">G   H   I   J</div><div class="line"> \ /     \ /</div><div class="line">  D   E   F</div><div class="line">   \  |  / \</div><div class="line">    \ | /   |</div><div class="line">     \|/    |</div><div class="line">      B     C</div><div class="line">       \   /</div><div class="line">        \ /</div><div class="line">         A</div><div class="line">A =      = A^0</div><div class="line">B = A^   = A^1     = A~1</div><div class="line">C = A^2  = A^2</div><div class="line">D = A^^  = A^1^1   = A~2</div><div class="line">E = B^2  = A^^2</div><div class="line">F = B^3  = A^^3</div><div class="line">G = A^^^ = A^1^1^1 = A~3</div><div class="line">H = D^2  = B^^2    = A^^^2  = A~2^2</div><div class="line">I = F^   = B^3^    = A^^3^</div><div class="line">J = F^2  = B^3^2   = A^^3^2</div></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://stackoverflow.com/questions/2221658/whats-the-difference-between-head-and-head-in-git" target="_blank" rel="external">http://stackoverflow.com/questions/2221658/whats-the-difference-between-head-and-head-in-git</a><br><a href="https://www.kernel.org/pub/software/scm/git/docs/git-rev-parse.html" target="_blank" rel="external">https://www.kernel.org/pub/software/scm/git/docs/git-rev-parse.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;在使用 Git 的时候，我们经常会看见 &lt;code&gt;~&lt;/code&gt; 和 &lt;code&gt;^&lt;/code&gt;，如 &lt;code&gt;HEAD~2&lt;/co
    
    </summary>
    
      <category term="tools" scheme="http://scarletsky.github.io/categories/tools/"/>
    
    
      <category term="git" scheme="http://scarletsky.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Restful API 中的错误处理</title>
    <link href="http://scarletsky.github.io/2016/11/30/error-handling-in-restful-api/"/>
    <id>http://scarletsky.github.io/2016/11/30/error-handling-in-restful-api/</id>
    <published>2016-11-30T09:02:18.000Z</published>
    <updated>2016-12-01T14:17:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>随着移动开发和前端开发的崛起，越来越多的 Web 后端应用都倾向于实现 Restful API。<br>Restful API 是一个简单易用的前后端分离方案，它只需要对客户端请求进行处理，然后返回结果即可， 无需考虑页面渲染，一定程度上减轻了后端开发人员的负担。<br>然而，正是由于 Restful API 不需要考虑页面渲染，导致它不能在页面上展示错误信息。<br>那就意着当出现错误的时候，它只能通过返回一个错误的响应，来告诉用户和开发者相应的错误信息，提示他们接下来应该怎么办。<br>本文将讨论 Restful API 中的错误处理方案。</p>
<h2 id="设计错误信息"><a href="#设计错误信息" class="headerlink" title="设计错误信息"></a>设计错误信息</h2><p>当 Restful API 需要抛出错误的时候，我们要考虑的是：这个错误应该包含哪些信息。<br>我们先看看 Github, Google, Facebook, Twitter, Twilio 的错误信息是怎样的。</p>
<p>Github (use http status)</p>
<figure class="highlight json"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"message"</span>: <span class="string">"Validation Failed"</span>,</div><div class="line">  <span class="attr">"errors"</span>: [</div><div class="line">    &#123;</div><div class="line">      <span class="attr">"resource"</span>: <span class="string">"Issue"</span>,</div><div class="line">      <span class="attr">"field"</span>: <span class="string">"title"</span>,</div><div class="line">      <span class="attr">"code"</span>: <span class="string">"missing_field"</span></div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Google (use http status)</p>
<figure class="highlight json"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"error"</span>: &#123;</div><div class="line">    <span class="attr">"errors"</span>: [</div><div class="line">      &#123;</div><div class="line">        <span class="attr">"domain"</span>: <span class="string">"global"</span>,</div><div class="line">        <span class="attr">"reason"</span>: <span class="string">"insufficientFilePermissions"</span>,</div><div class="line">        <span class="attr">"message"</span>: <span class="string">"The user does not have sufficient permissions for file &#123;fileId&#125;."</span></div><div class="line">      &#125;</div><div class="line">    ],</div><div class="line">    <span class="attr">"code"</span>: <span class="number">403</span>,</div><div class="line">    <span class="attr">"message"</span>: <span class="string">"The user does not have sufficient permissions for file &#123;fileId&#125;."</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Facebook (use http status)</p>
<figure class="highlight json"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"error"</span>: &#123;</div><div class="line">    <span class="attr">"message"</span>: <span class="string">"Message describing the error"</span>, </div><div class="line">    <span class="attr">"type"</span>: <span class="string">"OAuthException"</span>,</div><div class="line">    <span class="attr">"code"</span>: <span class="number">190</span>,</div><div class="line">    <span class="attr">"error_subcode"</span>: <span class="number">460</span>,</div><div class="line">    <span class="attr">"error_user_title"</span>: <span class="string">"A title"</span>,</div><div class="line">    <span class="attr">"error_user_msg"</span>: <span class="string">"A message"</span>,</div><div class="line">    <span class="attr">"fbtrace_id"</span>: <span class="string">"EJplcsCHuLu"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Twitter (use http status)</p>
<figure class="highlight json"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"errors"</span>: [</div><div class="line">    &#123;</div><div class="line">      <span class="attr">"message"</span>: <span class="string">"Sorry, that page does not exist"</span>,</div><div class="line">      <span class="attr">"code"</span>: <span class="number">34</span></div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Twilio (use http status)</p>
<figure class="highlight json"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"code"</span>: <span class="number">21211</span>,</div><div class="line">  <span class="attr">"message"</span>: <span class="string">"The 'To' number 5551234567 is not a valid phone number."</span>,</div><div class="line">  <span class="attr">"more_info"</span>: <span class="string">"https://www.twilio.com/docs/errors/21211"</span>,</div><div class="line">  <span class="attr">"status"</span>: <span class="number">400</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>观察这些结构可以发现它们都有一些共同的地方：</p>
<ul>
<li>都利用了 Http 状态码</li>
<li>有些返回了业务错误码</li>
<li>都提供了给用户看的错误提示信息</li>
<li>有些提供了给开发者看的错误信息</li>
</ul>
<h3 id="Http-状态码"><a href="#Http-状态码" class="headerlink" title="Http 状态码"></a>Http 状态码</h3><p>在 Restful API 中利用 Http 状态码来表明错误类型再合适不过了，因为 Http 状态码定义了很多抽象的错误类型。<br>虽然 Http 状态码定义了非常多的错误类型，但实际应用中，我们常用的状态码并不多，通常都是下面这几方面：</p>
<ul>
<li>API 正常工作 (200, 201)</li>
<li>客户端错误 (400, 401, 403, 404)</li>
<li>服务端错误 (500, 503)</li>
</ul>
<h3 id="业务错误码"><a href="#业务错误码" class="headerlink" title="业务错误码"></a>业务错误码</h3><p>很多时候，我们根据业务类型来自定义错误码。<br>这些业务错误码与 Http 状态码并不重叠，这时候我们可以返回业务错误码，用来提示用户/开发者错误类型。</p>
<h3 id="给用户看的错误信息"><a href="#给用户看的错误信息" class="headerlink" title="给用户看的错误信息"></a>给用户看的错误信息</h3><p>当出现错误的时候，我们需要提示用户如何处理这种情况，通常这种错误信息都是必须的。<br>可以看到上面几个例子中都有返回给用户看的错误信息。</p>
<h3 id="给开发者看的错误信息"><a href="#给开发者看的错误信息" class="headerlink" title="给开发者看的错误信息"></a>给开发者看的错误信息</h3><p>若我们的 API 需要开放给第三方开发者，那么我们就需要考虑返回一些给开发者看的错误信息。</p>
<h2 id="设计错误类型"><a href="#设计错误类型" class="headerlink" title="设计错误类型"></a>设计错误类型</h2><p>我们刚才提到过，可以利用 Http 状态码来为错误类型进行分类。<br>通常我们所说的分类通常是对客户端错误进行分类， 即 4xx 类型的错误。</p>
<p>而这些错误类型中，我们最常用的是：</p>
<ul>
<li><p>400 Bad Request<br>由于包含语法错误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。<br>通常在请求参数不合法或格式错误的时候可以返回这个状态码。</p>
</li>
<li><p>401 Unauthorized<br>当前请求需要用户验证。<br>通常在没有登录的状态下访问一些受保护的 API 时会用到这个状态码。</p>
</li>
<li><p>403 Forbidden<br>服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助。<br>通常在没有权限操作资源时(如修改/删除一个不属于该用户的资源时)会用到这个状态码。</p>
</li>
<li><p>404 Not Found<br>请求失败，请求所希望得到的资源未被在服务器上发现。<br>通常在找不到资源时返回这个状态码。</p>
</li>
</ul>
<p>尽管我们可以通过 Http 状态码来表示错误的类型，<br>但在实际应用中，如果仅仅使用 Http 状态码的话，我们的代码中就遍布 Http 状态码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Node.js</span></div><div class="line"><span class="keyword">if</span> (!res.body.title) &#123;</div><div class="line">  res.statusCode = <span class="number">400</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (!user) &#123;</div><div class="line">  res.statusCode = <span class="number">401</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (!post) &#123;</div><div class="line">  res.statusCode = <span class="number">404</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的实现方式在小项目中还可以接受，当项目变大、需求变多的时候，维护起来就变得很麻烦了。<br>为了提高错误的可读性和可维护性，我们需要对各种错误进行分类。<br>我个人习惯把错误分成以下几种类型：</p>
<ul>
<li>格式错误 (FORMAT_INVALID)</li>
<li>数据不存在 (DATA_NOT_FOUND)</li>
<li>数据已存在 (DATA_EXISTED)</li>
<li>数据无效 (DATA_INVALID)</li>
<li>登录错误 (LOGIN_REQUIRED)</li>
<li>权限不足 (PERMISSION_DENIED)</li>
</ul>
<p>错误分类之后，我们抛错误的时候就变得更加直观了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (!res.body.title) &#123;</div><div class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(ERROR.FORMAT_INVALID)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (!user) &#123;</div><div class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(ERROR.LOGIN_REQUIRED)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (!post) &#123;</div><div class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(ERROR.DATA_NOT_FOUND)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (post.creator.id !== user.id) &#123;</div><div class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(ERROR.PERMISSION_DENIED)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种形式比上面的写死状态码的方式方便很多，而且维护起来也更加简单。<br>但有一个问题，就是不能根据错误类型来返回指定的错误信息。</p>
<h2 id="自定义错误类型"><a href="#自定义错误类型" class="headerlink" title="自定义错误类型"></a>自定义错误类型</h2><p>要实现根据错误类型来返回指定的错误信息，我们可以通过自定义错误的方式来实现。<br>假设我们自定义错误的结构如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"type"</span>: <span class="string">""</span>,</div><div class="line">  <span class="attr">"code"</span>: <span class="number">0</span>,</div><div class="line">  <span class="attr">"message"</span>: <span class="string">""</span>,</div><div class="line">  <span class="attr">"detail"</span>: <span class="string">""</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们需要做到如下几点：</p>
<ul>
<li>根据错误类型来自动设置 <code>type</code>, <code>code</code>, <code>message</code></li>
<li><code>detail</code> 为可选项，用来描述该错误的具体原因</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> ERROR = &#123;</div><div class="line">  <span class="attr">FORMAT_INVALID</span>: <span class="string">'FORMAT_INVALID'</span>,</div><div class="line">  <span class="attr">DATA_NOT_FOUND</span>: <span class="string">'DATA_NOT_FOUND'</span>,</div><div class="line">  <span class="attr">DATA_EXISTED</span>: <span class="string">'DATA_EXISTED'</span>,</div><div class="line">  <span class="attr">DATA_INVALID</span>: <span class="string">'DATA_INVALID'</span>,</div><div class="line">  <span class="attr">LOGIN_REQUIRED</span>: <span class="string">'LOGIN_REQUIRED'</span>,</div><div class="line">  <span class="attr">PERMISSION_DENIED</span>: <span class="string">'PERMISSION_DENIED'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> ERROR_MAP = &#123;</div><div class="line">  <span class="attr">FORMAT_INVALID</span>: &#123;</div><div class="line">    <span class="attr">code</span>: <span class="number">1</span>,</div><div class="line">    <span class="attr">message</span>: <span class="string">'The request format is invalid'</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">DATA_NOT_FOUND</span>: &#123;</div><div class="line">    <span class="attr">code</span>: <span class="number">2</span>,</div><div class="line">    <span class="attr">message</span>: <span class="string">'The data is not found in database'</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">DATA_EXISTED</span>: &#123;</div><div class="line">    <span class="attr">code</span>: <span class="number">3</span>,</div><div class="line">    <span class="attr">message</span>: <span class="string">'The data has exist in database'</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">DATA_INVALID</span>: &#123;</div><div class="line">    <span class="attr">code</span>: <span class="number">4</span>,</div><div class="line">    <span class="attr">message</span>: <span class="string">'The data is invalid'</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">LOGIN_REQUIRED</span>: &#123;</div><div class="line">    code <span class="number">5</span>,</div><div class="line">    <span class="attr">message</span>: <span class="string">'Please login first'</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">PERMISSION_DENIED</span>: &#123;</div><div class="line">    <span class="attr">code</span>: <span class="number">6</span>,</div><div class="line">    <span class="attr">message</span>: <span class="string">'You have no permission to operate'</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CError</span> <span class="keyword">extends</span> <span class="title">Error</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(type, detail) &#123;</div><div class="line">    <span class="keyword">super</span>()</div><div class="line">    <span class="built_in">Error</span>.captureStackTrace(<span class="keyword">this</span>, <span class="keyword">this</span>.constructor)</div><div class="line"></div><div class="line">    <span class="keyword">let</span> error = ERROR_MAP[type]</div><div class="line">    <span class="keyword">if</span> (!error) &#123;</div><div class="line">      error = &#123;</div><div class="line">        <span class="attr">code</span>: <span class="number">999</span>,</div><div class="line">        <span class="attr">message</span>: <span class="string">'Unknow error type'</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.name = <span class="string">'CError'</span></div><div class="line">    <span class="keyword">this</span>.type = error.code !== <span class="number">999</span> ? type : <span class="string">'UNDEFINED'</span></div><div class="line">    <span class="keyword">this</span>.code = error.code</div><div class="line">    <span class="keyword">this</span>.message = error.message</div><div class="line">    <span class="keyword">this</span>.detail = detail</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>自定义好错误之后，我们调用起来就更加简单了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// in controller</span></div><div class="line"><span class="keyword">if</span> (!user) &#123;</div><div class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> CError(ERROR.LOGIN_REQUIRED, <span class="string">'You should login first'</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (!req.body.title) &#123;</div><div class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> CError(ERROR.FORMAT_INVALID, <span class="string">'Title is required'</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (!post) &#123;</div><div class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> CError(ERROR.DATA_NOT_FOUND, <span class="string">'The post you required is not found'</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后，还剩下一个问题，根据错误类型来设置状态码，然后返回错误信息给客户端。</p>
<h2 id="捕获错误信息"><a href="#捕获错误信息" class="headerlink" title="捕获错误信息"></a>捕获错误信息</h2><p>在 Controller 中抛出自定义错误后，我们需要捕获该错误，才能返回给客户端。<br>假设我们使用 koa 2 作为 web 框架来开发 restful api，那么我们要做的是添加错误处理的中间件:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">errorHandler</span> (<span class="params">ctx, next</span>) </span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">await</span> next()</div><div class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> status</div><div class="line"></div><div class="line">    <span class="keyword">switch</span> (err.type) &#123;</div><div class="line">      <span class="keyword">case</span> ERROR.FORMAT_INVALID:</div><div class="line">      <span class="keyword">case</span> ERROR.DATA_EXISTED:</div><div class="line">      <span class="keyword">case</span> ERROR.DATA_INVALID:</div><div class="line">        status = <span class="number">400</span></div><div class="line">        <span class="keyword">break</span></div><div class="line">      <span class="keyword">case</span> ERROR.LOGIN_REQUIRED:</div><div class="line">        status = <span class="number">401</span></div><div class="line">      <span class="keyword">case</span> ERROR.PERMISSION_DENIED:</div><div class="line">        status = <span class="number">403</span></div><div class="line">      <span class="keyword">case</span> ERROR.DATA_NOT_FOUND:</div><div class="line">        status = <span class="number">404</span></div><div class="line">        <span class="keyword">break</span></div><div class="line">      <span class="keyword">default</span>:</div><div class="line">        status = <span class="number">500</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ctx.status = status</div><div class="line">    ctx.body = err</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// in app.js</span></div><div class="line">app.use(errorHandler)</div><div class="line">app.use(router.routes())</div></pre></td></tr></table></figure>
<p>通过这种方式，我们就能优雅地处理 Restful API 中的错误信息了。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://zh.wikipedia.org/zh-hans/HTTP%E7%8A%B6%E6%80%81%E7%A0%81" target="_blank" rel="external">https://zh.wikipedia.org/zh-hans/HTTP%E7%8A%B6%E6%80%81%E7%A0%81</a><br><a href="https://www.loggly.com/blog/node-js-error-handling/" target="_blank" rel="external">https://www.loggly.com/blog/node-js-error-handling/</a><br><a href="http://blog.restcase.com/rest-api-error-codes-101/" target="_blank" rel="external">http://blog.restcase.com/rest-api-error-codes-101/</a><br><a href="https://apigee.com/about/blg/technology/restful-api-design-what-about-errors" target="_blank" rel="external">https://apigee.com/about/blg/technology/restful-api-design-what-about-errors</a><br><a href="http://stackoverflow.com/questions/942951/rest-api-error-return-good-practices" target="_blank" rel="external">http://stackoverflow.com/questions/942951/rest-api-error-return-good-practices</a><br><a href="http://goldbergyoni.com/checklist-best-practices-of-node-js-error-handling/" target="_blank" rel="external">http://goldbergyoni.com/checklist-best-practices-of-node-js-error-handling/</a><br><a href="http://blogs.mulesoft.com/dev/api-dev/api-best-practices-response-handling/" target="_blank" rel="external">http://blogs.mulesoft.com/dev/api-dev/api-best-practices-response-handling/</a><br><a href="https://developers.facebook.com/docs/graph-api/using-graph-api/#errors" target="_blank" rel="external">https://developers.facebook.com/docs/graph-api/using-graph-api/#errors</a><br><a href="https://developers.google.com/drive/v3/web/handle-errors" target="_blank" rel="external">https://developers.google.com/drive/v3/web/handle-errors</a><br><a href="https://developer.github.com/v3/#client-errors" target="_blank" rel="external">https://developer.github.com/v3/#client-errors</a><br><a href="https://dev.twitter.com/overview/api/response-codes" target="_blank" rel="external">https://dev.twitter.com/overview/api/response-codes</a><br><a href="https://www.twilio.com/docs/api/errors" target="_blank" rel="external">https://www.twilio.com/docs/api/errors</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;随着移动开发和前端开发的崛起，越来越多的 Web 后端应用都倾向于实现 Restful API。&lt;br&gt;Restful API 是一个简单易
    
    </summary>
    
    
      <category term="restful, error handling" scheme="http://scarletsky.github.io/tags/restful-error-handling/"/>
    
  </entry>
  
  <entry>
    <title>在 Node.js 中为 Restful API 编写单元测试</title>
    <link href="http://scarletsky.github.io/2016/10/05/write-unit-tests-for-restful-api-in-nodejs/"/>
    <id>http://scarletsky.github.io/2016/10/05/write-unit-tests-for-restful-api-in-nodejs/</id>
    <published>2016-10-05T03:57:26.000Z</published>
    <updated>2016-10-05T02:22:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>单元测试是针对程序模块来进行正确性检验的测试工作，程序单元是应用的最小可测试部件。<br>在 Web 应用中，我们可以把 Restful API 看作是构成应用的单元。<br>Restful API 比较好测试，测试起来也比较简单。<br>本文将介绍编写测试的原因和原则，然后以 Node.js 为例子介绍测试 Restful API 的方法。</p>
<h2 id="为什么要编写测试"><a href="#为什么要编写测试" class="headerlink" title="为什么要编写测试"></a>为什么要编写测试</h2><p>每个开发者都知道单元测试的重要性，但并不是每个开发者都会去编写单元测试。原因也很容易理解：</p>
<ul>
<li>编写测试需要更多的时间，会拖慢项目进度</li>
<li>编写测试需要写更多的代码，更容易出现错误</li>
<li>当需求更变后，我们要花更多的精力去修改测试代码</li>
<li>有时候测试代码可能会比源代码多几倍</li>
</ul>
<p>我以前也抱有类似的想法，认为人工测试就足够了，没必要特意去编写单元测试。<br>然而随着项目的规模的增大，代码也会慢慢出现意外。<br>最典型的例子是为了某需求修改了 A 位置，需求完成了，而 B 位置就出现了 Bug。</p>
<p>在读过 <a href="http://www.yinwang.org/blog-cn/2016/09/14/tests" target="_blank" rel="external">王垠大神的《测试的道理》</a> 之后，我更加明白了一个道理：我没有大神般的编码能力，我只能通过单元测试来检验自己的编码。</p>
<p>除了检验代码的正确性之外，我认为单元测试还有一个很重要的作用：为日后重构项目做准备。<br>只要单元测试覆盖得够好，以后重构的时候就很容易发现问题，节约大量的时间。</p>
<p>轮子哥在 <a href="https://www.zhihu.com/question/28729261/answer/94964928" target="_blank" rel="external">知乎</a> 上说过一句很有意思的话：</p>
<blockquote>
<p>所以那些专门写不需要维护的软件的人，讨厌测试，也是情有可原的。</p>
</blockquote>
<p>如果你要编写一个长期维护的软件，那么你最好添加单元测试。</p>
<h2 id="F-I-R-S-T-原则"><a href="#F-I-R-S-T-原则" class="headerlink" title="F.I.R.S.T 原则"></a>F.I.R.S.T 原则</h2><p>当我们决定要编写单元测试之后，我们就要考虑怎样 <strong>写好</strong> 单元测试，换句话说就是编写单元测试时需要注意哪些原则。<br>那么，有哪些原则是我们需要注意的呢？</p>
<ul>
<li><strong>Fast</strong>: 测试必须是快速的</li>
<li><strong>Isolated / Independent</strong>: <ul>
<li>每个测试都要做 3 A =&gt; Arrange(准备), Act(行动), Assert(断言)</li>
<li>Arrange: 测试过程中用到的数据不能依赖于运行环境，测试中用到的数据应是测试中的一部分</li>
<li>Act: 调用你想要测试的方法 / API</li>
<li>Assert: 根据返回结果进行断言</li>
<li>测试结果不能依赖运行环境</li>
<li>测试结果不依赖运行测试的顺序</li>
</ul>
</li>
<li><strong>Repeatable</strong>:<ul>
<li>每个测试必须是可重复执行的，即运行 N 次，会得到 N 次相同的结果</li>
<li>每个测试的结果不应依赖时间，日期，和随机数的输出</li>
</ul>
</li>
<li><strong>Self-validating</strong>: <ul>
<li>每个测试都可以自己判断结果来判断测试是否通过</li>
<li>不需要人类去查阅手册来判断结果</li>
</ul>
</li>
<li><strong>Thorough and Timely</strong>:<ul>
<li>应该尽量覆盖所有使用场景</li>
<li>应该尝试测试驱动开发(TDD)</li>
</ul>
</li>
</ul>
<p>这就是经典的 F.I.R.S.T 原则。<br>我们最好时刻注意自己编写的单元测试是否遵守这些原则。</p>
<p>JavaScript 社区里有很多测试框架可以用来编写单元测试，有 <code>ava</code>、<code>mocha</code>、<code>jasmine</code>、<code>tap</code> 等。<br>这些测试框架都有提供 <code>beforeEach</code>、<code>afterEach</code> API，目的是隔离我们的测试数据，从而满足 <strong>Isolated / Independent</strong> 和 <strong>Repeatable</strong> 原则。</p>
<h2 id="编写单元测试"><a href="#编写单元测试" class="headerlink" title="编写单元测试"></a>编写单元测试</h2><p>假设我们有以下 Restful API (用了 jwt 来做用户验证):</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router()</div><div class="line"><span class="comment">// 根据 token 获取用户信息，必须登录</span></div><div class="line">router.get(<span class="string">'/user'</span>, jwt, user.getSelf)</div><div class="line"><span class="comment">// 获取用户列表，无需登录</span></div><div class="line">router.get(<span class="string">'/users'</span>, user.getList)</div><div class="line"><span class="comment">// 获取指定用户信息，无需登录</span></div><div class="line">router.get(<span class="string">'/users/:userId'</span>, user.get)</div><div class="line"><span class="comment">// 创建新用户(用户注册)，无需登录</span></div><div class="line">router.post(<span class="string">'/users'</span>, user.create)</div><div class="line"><span class="comment">// 更新用户信息，必须登录</span></div><div class="line">router.put(<span class="string">'/user'</span>, jwt, user.update)</div></pre></td></tr></table></figure>
<p>那么我们应该怎样为这些 Restful API 编写单元测试呢？</p>
<p>最基本流程是：</p>
<ul>
<li>为 app 创建 http 服务器</li>
<li>对各个 API 发出请求</li>
<li>对响应内容进行断言</li>
</ul>
<p>幸运的是，社区里已经有相应的工具让我们可以方便管理这个流程，这个工具就是 —— <code>supertest</code>。<br>它提供了非常灵活的 API，足以帮助我们测试 Restful API 了。<br>基本用法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> app = <span class="built_in">require</span>(<span class="string">'../app'</span>)</div><div class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">'supertest'</span>)(app)</div><div class="line"></div><div class="line">request</div><div class="line">  .get(<span class="string">'/users'</span>)</div><div class="line">  .expect(<span class="number">200</span>)</div><div class="line">  .end(<span class="function">(<span class="params">err, res</span>) =&gt;</span> &#123;</div><div class="line">    res.body.should.be.an.Array()</div><div class="line">  &#125;)</div></pre></td></tr></table></figure>
<blockquote>
<p>提示<br>如果你遇到了 <code>TypeError: app.address is not a function</code>, 请尝试一下以下方法：<br><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">'supertest'</span>).agent(app.listen())</div></pre></td></tr></table></figure></p>
</blockquote>
<p>现在，我们可以把 <code>supertest</code> 和其他测试框架整合起来了，我选择了 <code>mocha</code> 作为例子，因为它很经典，当你会用 <code>mocha</code> 之后，其他测试框架基本上就难不倒你了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>)</div><div class="line"><span class="keyword">const</span> &#123; ObjectId &#125; = <span class="built_in">require</span>(<span class="string">'mongoose'</span>).Types</div><div class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'../config'</span>)</div><div class="line"><span class="keyword">const</span> UserModel = <span class="built_in">require</span>(<span class="string">'../models/user'</span>)</div><div class="line"><span class="keyword">const</span> app = <span class="built_in">require</span>(<span class="string">'../app'</span>)</div><div class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">'supertest'</span>)(app)</div><div class="line"></div><div class="line">describe(<span class="string">'User API'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// 为每个单元测试初始化数据</span></div><div class="line">  <span class="comment">// 每个单元测试中可以通过 context 来访问相关的数据</span></div><div class="line">  beforeEach(<span class="function"><span class="keyword">function</span> (<span class="params">done</span>) </span>&#123;</div><div class="line">    co(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</div><div class="line">      self.user1 = <span class="keyword">yield</span> UserModel.create(&#123; <span class="attr">username</span>: <span class="string">'user1'</span> &#125;)</div><div class="line">      self.token = jwt.sign(&#123; <span class="attr">_id</span>: self.user1._id &#125;, config.jwtSecret, &#123; <span class="attr">expiresIn</span>: <span class="number">3600</span> &#125;)</div><div class="line">      done()</div><div class="line">    &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'err: '</span>, err)</div><div class="line">      done()</div><div class="line">    &#125;)</div><div class="line">  &#125;)</div><div class="line"></div><div class="line">  <span class="comment">// 正常情况下访问 /user</span></div><div class="line">  it(<span class="string">'should get user info when GET /user with token'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">done</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> self = <span class="keyword">this</span></div><div class="line">    request</div><div class="line">      .get(<span class="string">'/user'</span>)</div><div class="line">      .set(<span class="string">'Authorization'</span>, self.token)</div><div class="line">      .expect(<span class="number">200</span>)</div><div class="line">      .end(<span class="function">(<span class="params">err, res</span>) =&gt;</span> &#123;</div><div class="line">        res.body._id.should.equal(self.user1._id)</div><div class="line">        done()</div><div class="line">      &#125;)</div><div class="line">  &#125;)</div><div class="line"></div><div class="line">  <span class="comment">// 非正常情况下访问 /user</span></div><div class="line">  it(<span class="string">'should return 403 when GET /user without token'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">done</span>) </span>&#123;</div><div class="line">    request</div><div class="line">      .get(<span class="string">'/user'</span>)</div><div class="line">      .expect(<span class="number">403</span>, done)</div><div class="line">  &#125;)</div><div class="line"></div><div class="line">  <span class="comment">// 访问 /users，登录用户和非登录用户都会得到相同的结果，所以不需要区别对待</span></div><div class="line">  it(<span class="string">'should return user list when GET /users'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">done</span>) </span>&#123;</div><div class="line">    request</div><div class="line">      .get(<span class="string">'/users'</span>)</div><div class="line">      .expect(<span class="number">200</span>)</div><div class="line">      .end(<span class="function">(<span class="params">err, res</span>) =&gt;</span> &#123;</div><div class="line">        res.body.should.be.an.Array()</div><div class="line">        done()</div><div class="line">      &#125;)</div><div class="line">  &#125;)</div><div class="line"></div><div class="line">  <span class="comment">// 访问 /users/:userId 也不需要区分登录和非登录状态</span></div><div class="line">  it(<span class="string">'should return user info when GET /users/:userId'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">done</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> self = <span class="keyword">this</span></div><div class="line">    request</div><div class="line">      .get(<span class="string">`/users/<span class="subst">$&#123;self.user1._id&#125;</span>`</span>)</div><div class="line">      .expect(<span class="number">200</span>)</div><div class="line">      .end(<span class="function">(<span class="params">err, res</span>) =&gt;</span> &#123;</div><div class="line">        res.body._id.should.equal(self.user1._id)</div><div class="line">        done()</div><div class="line">      &#125;)</div><div class="line">  &#125;)</div><div class="line"></div><div class="line">  <span class="comment">// 访问不存在的用户，我们需要构造一个虚假的用户 id</span></div><div class="line">  it(<span class="string">'should return 404 when GET /users/$&#123;non-existent&#125;'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">done</span>) </span>&#123;</div><div class="line">    request</div><div class="line">      .get(<span class="string">`/users/<span class="subst">$&#123;ObjectId()&#125;</span>`</span>)</div><div class="line">      .expect(<span class="number">404</span>, done)</div><div class="line">  &#125;)</div><div class="line"></div><div class="line">  <span class="comment">// 正常情况下的用户注册不会带上 token</span></div><div class="line">  it(<span class="string">'should return user info when POST /user'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">done</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> username = <span class="string">'test user'</span></div><div class="line">    request</div><div class="line">      .post(<span class="string">'/users'</span>)</div><div class="line">      .send(&#123; <span class="attr">username</span>: username &#125;)</div><div class="line">      .expect(<span class="number">200</span>)</div><div class="line">      .end(<span class="function">(<span class="params">err, res</span>) =&gt;</span> &#123;</div><div class="line">        res.body.username.should.equal(username)</div><div class="line">        done()</div><div class="line">      &#125;)</div><div class="line">  &#125;)</div><div class="line"></div><div class="line">  <span class="comment">// 非法情况下的用户注册，带上了 token 的请求要判断为非法请求</span></div><div class="line">  it(<span class="string">'should return 400 when POST /user with token'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">done</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> username = <span class="string">'test user 2'</span></div><div class="line">    request</div><div class="line">      .post(<span class="string">'/users'</span>)</div><div class="line">      .set(<span class="string">'Authorization'</span>, <span class="keyword">this</span>.token)</div><div class="line">      .send(&#123; <span class="attr">username</span>: username &#125;)</div><div class="line">      .expect(<span class="number">400</span>, done)</div><div class="line">  &#125;)</div><div class="line"></div><div class="line">  <span class="comment">// 正常情况下更新用户信息，需要带上 token</span></div><div class="line">  it(<span class="string">'should return 200 when PUT /user with token'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">done</span>) </span>&#123;</div><div class="line">    request</div><div class="line">      .put(<span class="string">'/user'</span>)</div><div class="line">      .set(<span class="string">'Authorization'</span>, <span class="keyword">this</span>.token)</div><div class="line">      .send(&#123; <span class="attr">username</span>: <span class="string">'valid username'</span> &#125;)</div><div class="line">      .expect(<span class="number">200</span>, done)</div><div class="line">  &#125;)</div><div class="line"></div><div class="line">  <span class="comment">// 非法情况下更新用户信息，如缺少 token</span></div><div class="line">  it(<span class="string">'should return 400 when PUT /user without token'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">done</span>) </span>&#123;</div><div class="line">    request</div><div class="line">      .put(<span class="string">'/user'</span>)</div><div class="line">      .send(&#123; <span class="attr">username</span>: <span class="string">'valid username'</span> &#125;)</div><div class="line">      .expect(<span class="number">400</span>, done)</div><div class="line">  &#125;)</div><div class="line"></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>可以看到，为 Restful API 编写单元测试还有一个优点，就是可以轻易区分登录状态和非登录状态。如果要在用户界面中测试这些功能，那么就需要不停地登录和注销，将会是一项累人的工作~<br>另外，上面的例子中基本都是对返回状态吗进行断言的，你可以按照自己的需要进行断言。</p>
<blockquote>
<p>提示<br>你可以选择自己喜欢的断言库，我这里选择了 should.js，原因是好读。<br>个人认为 should.js 和其他断言库比起来有个缺点，就是不好写。<br>value.should.xxx.yyy.zzz 这个形式和 assert.equal(value, expected) 相比不太直观。<br>另外由于 should.js 是通过扩展 Object.prototype 的原型来实现的，但 null 值是一个例外，它不能访问任何属性。<br>因此 should.js 在 null 上会失效。<br>一个变通的办法是 <code>(value === null).should.equal(true)</code>。</p>
</blockquote>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ npm test</div><div class="line"></div><div class="line">  User api</div><div class="line">    ✓ should get user info when GET /user with token</div><div class="line">    ✓ should return 403 when GET /user without token</div><div class="line">    ✓ should return user list when GET /users</div><div class="line">    ✓ should return user info when GET /users/:userId</div><div class="line">    ✓ should return 404 when GET /users/$&#123;non-existent&#125;</div><div class="line">    ✓ should return user info when POST /user</div><div class="line">    ✓ should return 400 when POST /user with token</div><div class="line">    ✓ should return 200 when PUT /user with token</div><div class="line">    ✓ should return 400 when PUT /user without token</div></pre></td></tr></table></figure>
<p>当我们运行测试时，看到自己编写的测试都通过时，心里都会非常踏实。<br>而当我们要对项目进行重构时，这些测试用例会帮我们发现重构过程中的问题，减少 Debug 时间，提升重构时的效率。</p>
<h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><h3 id="如何连接测试数据库"><a href="#如何连接测试数据库" class="headerlink" title="如何连接测试数据库"></a>如何连接测试数据库</h3><p>在 Node.js 的环境下，我们可以设置环境变量 <code>NODE_ENV=test</code>，然后通过这个环境变量去连接测试数据库，这样测试数据就不会存在于开发环境下的数据库拉！</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// config.js</span></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  <span class="attr">development</span>: &#123;&#125;,</div><div class="line">  <span class="attr">production</span>: &#123;&#125;,</div><div class="line">  <span class="attr">test</span>: &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// app.js</span></div><div class="line"><span class="keyword">const</span> ENV = process.NODE_ENV || <span class="string">'development'</span></div><div class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'./config'</span>)[ENV]</div><div class="line"><span class="comment">// connect db by config</span></div></pre></td></tr></table></figure>
<h3 id="如何清空测试数据库"><a href="#如何清空测试数据库" class="headerlink" title="如何清空测试数据库"></a>如何清空测试数据库</h3><p>清空数据库这种一次性的工作最好放到 npm scripts 中处理，需要进行清空操作的时候直接运行 <code>npm run resetDB</code> 就可以了。<br>需要注意的是，编写清空数据库脚本时必须判断环境变量 <code>NODE_ENV</code>，以免误删 production 环境下的数据。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// resetDB.js</span></div><div class="line"><span class="keyword">const</span> env = process.NODE_ENV || <span class="string">'development'</span></div><div class="line"><span class="keyword">if</span> (env === <span class="string">'test'</span> || env === <span class="string">'development'</span>) &#123;</div><div class="line">  <span class="comment">// connect db and delete data</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'You can not run this script in production.'</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// package.json</span></div><div class="line">&#123;</div><div class="line">  <span class="string">"scripts"</span>: &#123;</div><div class="line">    <span class="string">"resetDB"</span>: <span class="string">"node scripts/resetDB.js"</span></div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="何时清空测试环境的数据库"><a href="#何时清空测试环境的数据库" class="headerlink" title="何时清空测试环境的数据库"></a>何时清空测试环境的数据库</h3><p>如果是按照上面的原则来生成测试数据的话，测试数据其实可以不用删掉的。<br>但由于测试数据会占用我们的空间，最好还是把这些测试数据删掉。<br>那么，清空测试数据库这个操作在测试前执行好，还是测试后执行好？<br>我个人倾向于测试前删除，因为有时候我们需要进入数据库，查看测试数据的正确性。<br>如果在测试后清空测试数据库的话，我们就没办法访问到测试数据了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"scripts"</span>: &#123;</div><div class="line">    <span class="string">"resetDB"</span>: <span class="string">"node scripts/resetDB.js"</span>,</div><div class="line">    <span class="string">"test"</span>: <span class="string">"NODE_ENV=test npm run resetDB &amp;&amp; mocha --harmony"</span></div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://zh.wikipedia.org/zh-cn/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95" target="_blank" rel="external">https://zh.wikipedia.org/zh-cn/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95</a><br><a href="http://blog.hubstaff.com/why-you-should-write-unit-tests/" target="_blank" rel="external">http://blog.hubstaff.com/why-you-should-write-unit-tests/</a><br><a href="http://www.yinwang.org/blog-cn/2016/09/14/tests" target="_blank" rel="external">http://www.yinwang.org/blog-cn/2016/09/14/tests</a><br><a href="https://www.zhihu.com/question/28729261/answer/94964928" target="_blank" rel="external">https://www.zhihu.com/question/28729261/answer/94964928</a><br><a href="http://agileinaflash.blogspot.de/2009/02/first.html" target="_blank" rel="external">http://agileinaflash.blogspot.de/2009/02/first.html</a><br><a href="http://howtodoinjava.com/best-practices/first-principles-for-good-tests/" target="_blank" rel="external">http://howtodoinjava.com/best-practices/first-principles-for-good-tests/</a><br><a href="https://github.com/ghsukumar/SFDC_Best_Practices/wiki/F.I.R.S.T-Principles-of-Unit-Testing" target="_blank" rel="external">https://github.com/ghsukumar/SFDC_Best_Practices/wiki/F.I.R.S.T-Principles-of-Unit-Testing</a><br><a href="https://github.com/sindresorhus/awesome-nodejs#testing" target="_blank" rel="external">https://github.com/sindresorhus/awesome-nodejs#testing</a><br><a href="https://github.com/visionmedia/supertest" target="_blank" rel="external">https://github.com/visionmedia/supertest</a><br><a href="https://yq.aliyun.com/articles/57804" target="_blank" rel="external">https://yq.aliyun.com/articles/57804</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;单元测试是针对程序模块来进行正确性检验的测试工作，程序单元是应用的最小可测试部件。&lt;br&gt;在 Web 应用中，我们可以把 Restful A
    
    </summary>
    
      <category term="javascript" scheme="http://scarletsky.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://scarletsky.github.io/tags/javascript/"/>
    
      <category term="nodejs" scheme="http://scarletsky.github.io/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>浅谈单页应用中前端分页的实现方案</title>
    <link href="http://scarletsky.github.io/2016/09/11/talking-about-front-end-pagination-implementation-in-spa/"/>
    <id>http://scarletsky.github.io/2016/09/11/talking-about-front-end-pagination-implementation-in-spa/</id>
    <published>2016-09-11T10:07:06.000Z</published>
    <updated>2016-09-11T15:37:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>分页是开发中最常见的需求之一。<br>对于分页，我们讨论的最多的是后端的数据库分页，这关乎到我们应用程序的性能，也是分页这个需求的核心。<br>而前端要做的，是把后端返回的数据呈现在页面上，工作被认为是简单琐碎的。<br>在单页应用中，我们有很多中分页方案，最常见的是无限滚动、上一页 &amp; 下一页和页码。<br>本文将谈谈这三种分页方式。</p>
<h2 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h2><p>无论使用哪种分页方案，我们都需要处理一些通用的需求，如：</p>
<ul>
<li>解析 url，提取当前页面的参数</li>
<li>根据返回数据生成自定义 DOM</li>
<li>移除某个 Node 节点中的所有子元素</li>
<li>往某个 Node 节点中插入元素列表</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 解析 url 中的查询字符串</span></div><div class="line"><span class="comment">// 如 http://host/items?page=5 中提取 page=5 中的 5</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">parsePage</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> searchString = <span class="built_in">window</span>.location.search.substr(<span class="number">1</span>).split(<span class="string">'&amp;'</span>).filter(<span class="function"><span class="params">v</span> =&gt;</span> v.indexOf(<span class="string">'page'</span>) !== <span class="number">-1</span>)[<span class="number">0</span>];</div><div class="line">    <span class="keyword">var</span> page = <span class="built_in">Number</span>(searchString.split(<span class="string">'='</span>)[<span class="number">1</span>]);</div><div class="line">    <span class="keyword">return</span> <span class="built_in">isNaN</span>(page) ? <span class="number">1</span> : page;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 生成自定义 DOM</span></div><div class="line"><span class="comment">// generateItemView :: Object -&gt; DOM Node</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateItemView</span>(<span class="params">object</span>) </span>&#123; <span class="comment">/* implementation */</span> &#125;</div><div class="line"></div><div class="line"><span class="comment">// 移除 Node 中所有子节点</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeItems</span>(<span class="params">node</span>) </span>&#123;</div><div class="line">    <span class="keyword">while</span> (node.firstChild) &#123;</div><div class="line">        node.removeChild(node.firstChild);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 往 Node 中插入元素列表</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertItems</span>(<span class="params">node, items</span>) </span>&#123;</div><div class="line">    items.forEach(<span class="function"><span class="params">item</span> =&gt;</span> node.appendChild(generateItemView(item)));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下文的示例代码中会直接调用这些函数，不再重复定义。</p>
<h2 id="无限滚动"><a href="#无限滚动" class="headerlink" title="无限滚动"></a>无限滚动</h2><p>无论对从前端还是后端来说，无限滚动都是我认为最简单的分页方案。<br>对后端来说，按照 <code>page</code> 和 <code>limit</code> 直接查出范围，然后返回一个数组给前端即可，不需要像其他方案那样还要查询总数。<br>对前端来说，直接根据后端返回的数据进行拼接即可，当后端返回一个空数组时，可以认为已经到最后一页，这时候就不需要再发请求到后端了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 后端返回的数据结构</span></div><div class="line"><span class="comment">// GET /items?page=5</span></div><div class="line">&#123; <span class="attr">items</span>: [...] &#125;</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 前端处理</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getItems</span>(<span class="params">page</span>) </span>&#123;</div><div class="line">    fetch(<span class="string">`/items?page=<span class="subst">$&#123;page&#125;</span>`</span>)</div><div class="line">        .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</div><div class="line">        .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</div><div class="line">            <span class="keyword">if</span> (res.items.length &gt; <span class="number">0</span>) &#123;</div><div class="line">                insertItems(</div><div class="line">                    <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>),</div><div class="line">                    res.items</div><div class="line">                );</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                alert(<span class="string">'No more data'</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>无限滚动虽然实现起来简单，用户体验也不错，但有一些致命的缺点：</p>
<ul>
<li>容易出现性能问题</li>
<li>容易丢失浏览进度</li>
</ul>
<p>目前有一些方案可以解决这些缺点：性能问题可以通过动态渲染来解决，而丢失浏览进度则可以通过简单的新开窗口来解决。</p>
<h2 id="上一页-amp-下一页"><a href="#上一页-amp-下一页" class="headerlink" title="上一页 &amp; 下一页"></a>上一页 &amp; 下一页</h2><p>这种分页方式和无限滚动比起来，会复杂一点点。<br>最主要是因为后端需要查询总数，然后根据当前页数来计算是否可以查询上一页或下一页。<br>当然，计算这部分可以在后端做，也可以在前端做。</p>
<h3 id="后端计算"><a href="#后端计算" class="headerlink" title="后端计算"></a>后端计算</h3><p>如果在后端计算，那么后端要做的事情就有：</p>
<ul>
<li>查询总数</li>
<li>计算 <code>hasPrev</code> 和 <code>hasNext</code></li>
<li>查询元素列表</li>
</ul>
<p>而前端方面则相对简单：</p>
<ul>
<li>根据后端返回的 <code>hasPrev</code> 和 <code>hasNext</code> 来判断是否需要显示上一页/下一页按钮</li>
<li>移除容器内的所有元素，再插入新的元素（即用新元素替换旧元素）</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 后端返回数据结构</span></div><div class="line"><span class="comment">// GET /items?page=5</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// hasPrev 和 hasNext 都需要后端去查询总数，然后计算出来</span></div><div class="line">    hasPrev: <span class="literal">true</span>,</div><div class="line">    <span class="attr">hasNext</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">items</span>: [...]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 前端处理</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getItems</span>(<span class="params">page</span>) </span>&#123;</div><div class="line">    fetch(<span class="string">`/items?page=<span class="subst">$&#123;page&#125;</span>`</span>)</div><div class="line">        .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</div><div class="line">        .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</div><div class="line">            res.hasPrev</div><div class="line">                ? <span class="built_in">document</span>.getElementById(<span class="string">'prevButton'</span>).style.display = <span class="string">'block'</span></div><div class="line">                : <span class="built_in">document</span>.getElementById(<span class="string">'prevButton'</span>).style.display = <span class="string">'none'</span>;</div><div class="line"></div><div class="line">            res.hasNext</div><div class="line">                ? <span class="built_in">document</span>.getElementById(<span class="string">'nextButton'</span>).style.display = <span class="string">'block'</span></div><div class="line">                : <span class="built_in">document</span>.getElementById(<span class="string">'nextButton'</span>).style.display = <span class="string">'none'</span>;</div><div class="line"></div><div class="line">            <span class="keyword">var</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>);</div><div class="line">            removeItems(container);</div><div class="line">            insertItems(container, res.items);</div><div class="line">        &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方案实现起来比较简单，但缺点是每次分页都需要查询总页数，浪费资源。</p>
<h3 id="前端计算"><a href="#前端计算" class="headerlink" title="前端计算"></a>前端计算</h3><p>如果是前端计算的话，那么后端要做的事情就相对简单，只要再提供一个查询总数的接口即可。<br>而前端方面，需要做更多的事情，同时要考虑当前端数据丢失时（如用户刷新页面）的处理方案。</p>
<ul>
<li>第一次加载页面时需要调用一次查询总数的接口，同时调用获取元素的接口</li>
<li>返回数据后计算 <code>hasPrev</code> 和 <code>hasNext</code>，用来判断是否需要显示上一页/下一页按钮</li>
<li>移除容器内的所有元素，再插入新的元素（即用新元素替换旧元素）</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 后端返回数据结构</span></div><div class="line"><span class="comment">// GET /itemsCount</span></div><div class="line">&#123; <span class="attr">total</span>: <span class="number">100</span> &#125;</div><div class="line"></div><div class="line"><span class="comment">// GET /items?page=5</span></div><div class="line">&#123; <span class="attr">items</span>: [...] &#125;</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 前端处理</span></div><div class="line"><span class="keyword">var</span> total = <span class="number">0</span>;</div><div class="line"><span class="keyword">var</span> limit = <span class="number">10</span>;</div><div class="line"></div><div class="line"><span class="built_in">window</span>.onload = getItemsCount(getItems);</div><div class="line"></div><div class="line"><span class="comment">// 获取总数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getItemsCount</span>(<span class="params">callback</span>) </span>&#123;</div><div class="line">    fetch(<span class="string">'/itemsCount'</span>)</div><div class="line">        .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</div><div class="line">        .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</div><div class="line">            total = res.total;</div><div class="line">            callback.call(<span class="literal">null</span>, parsePage());</div><div class="line">        &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getItems</span>(<span class="params">page</span>) </span>&#123;</div><div class="line">    fetch(<span class="string">`/items?page=<span class="subst">$&#123;page&#125;</span>`</span>)</div><div class="line">        .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</div><div class="line">        .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</div><div class="line">            <span class="keyword">var</span> hasPrev = page != <span class="number">1</span>;</div><div class="line">            <span class="keyword">var</span> hasNext = page != <span class="built_in">Math</span>.ceil(total / limit);</div><div class="line">            hasPrev</div><div class="line">                ? <span class="built_in">document</span>.getElementById(<span class="string">'prevButton'</span>).style.display = <span class="string">'block'</span></div><div class="line">                : <span class="built_in">document</span>.getElementById(<span class="string">'prevButton'</span>).style.display = <span class="string">'none'</span>;</div><div class="line"></div><div class="line">            hasNext</div><div class="line">                ? <span class="built_in">document</span>.getElementById(<span class="string">'nextButton'</span>).style.display = <span class="string">'block'</span></div><div class="line">                : <span class="built_in">document</span>.getElementById(<span class="string">'nextButton'</span>).style.display = <span class="string">'none'</span>;</div><div class="line"></div><div class="line">            <span class="keyword">var</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>);</div><div class="line">            removeItems(container);</div><div class="line">            insertItems(container, res.items);</div><div class="line">        &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方案可以让后端甩锅给前端，前端的活又变多拉！</p>
<h2 id="页码"><a href="#页码" class="headerlink" title="页码"></a>页码</h2><p>最后我们谈谈页码分页。<br>这个方案和「上一页 &amp; 下一页」的方案很类似，不同的地方在于这个方案需要根据当前页面和总数来生成页码。<br>生成页码是这个方案最麻烦的地方。举个简单的例子，假设我们的数据有 50 页，我们不可能把所有页码都显示出来，需要生成一组不连续的页码。</p>
<p>我们可以采用下面的形式来显示页面：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ------------------------------</span></div><div class="line"><span class="comment">// 我个人比较喜欢用 -1 来表示省略的区域</span></div><div class="line"><span class="comment">// 在生成 DOM 的时候，可以用省略号来展示</span></div><div class="line"><span class="comment">// ------------------------------</span></div><div class="line"><span class="comment">// 假设当前是第 1 页</span></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">-1</span>, <span class="number">50</span>]</div><div class="line"></div><div class="line"><span class="comment">// 假设当前是第 3 页</span></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">-1</span>, <span class="number">50</span>]</div><div class="line"></div><div class="line"><span class="comment">// 假设当前是第 25 页</span></div><div class="line">[<span class="number">1</span>, <span class="number">-1</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">-1</span>, <span class="number">50</span>]</div><div class="line"></div><div class="line"><span class="comment">// 假设当前是第 48 页</span></div><div class="line">[<span class="number">1</span>, <span class="number">-1</span>, <span class="number">46</span>, <span class="number">47</span>, <span class="number">48</span>, <span class="number">49</span>, <span class="number">50</span>]</div><div class="line"></div><div class="line"><span class="comment">// 假设当前是第 50 页</span></div><div class="line">[<span class="number">1</span>, <span class="number">-1</span>, <span class="number">48</span>, <span class="number">49</span>, <span class="number">50</span>]</div></pre></td></tr></table></figure>
<p>生成页码的原则通常都是：</p>
<ul>
<li>第一页和最后一页必须展示</li>
<li>其他页面按需展示，通常是当前页面的前后两页（即 x +- 2）</li>
<li>当页数少于 10 页的时候，直接显示出所有页码（为什么是 10 页？其实在满足前两个原则的情况下，只要 7 页省略号就会正常显示了。但页数较少的情况下显示省略号感觉怪怪的。）</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> lastPage = <span class="built_in">Math</span>.ceil(total / limit);</div><div class="line"></div><div class="line"><span class="comment">// 根据当前页生成动态页码</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">genPages</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (lastPage &lt;= <span class="number">10</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Array</span>(lastPage).fill().map(<span class="function">(<span class="params">v, i</span>) =&gt;</span> i + <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// dynamicPages 为除第一页和最后一页之外的页码，-1 表示省略号</span></div><div class="line">    <span class="keyword">var</span> dynamicPages;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (page === <span class="number">1</span>) &#123;</div><div class="line">        dynamicPages = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">-1</span>];</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (page === <span class="number">2</span>) &#123;</div><div class="line">        dynamicPages = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">-1</span>];</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (page === <span class="number">3</span>) &#123;</div><div class="line">        dynamicPages = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">-1</span>];</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (page === lastPage - <span class="number">2</span>) &#123;</div><div class="line">        dynamicPages = [<span class="number">-1</span>, page - <span class="number">2</span>, page - <span class="number">1</span>, page, page + <span class="number">1</span>];</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (page === lastPage - <span class="number">1</span>) &#123;</div><div class="line">        dynamicPages = [<span class="number">-1</span>, page - <span class="number">2</span>, page - <span class="number">1</span>, page];</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (page === lastPage) &#123;</div><div class="line">        dynamicPages = [<span class="number">-1</span>, page - <span class="number">2</span>, page - <span class="number">1</span>];</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        dynamicPages = [<span class="number">-1</span>, page - <span class="number">2</span>, page - <span class="number">1</span>, page, page + <span class="number">1</span>, page + <span class="number">2</span>, <span class="number">-1</span>];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    dynamicPages.unshift(<span class="number">1</span>);</div><div class="line">    dynamicPages.push(lastPage);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> dynamicPages;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>生成动态页码这部分的逻辑，无论放在前端还是后端都影响不大，可以按照自己需要去选择。<br>至于其他部分的细节，和「上一页 &amp; 下一页」类似，这里就不再重复了。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/xitu/gold-miner/blob/master/TODO/ux-infinite-scrolling-vs-pagination.md" target="_blank" rel="external">https://github.com/xitu/gold-miner/blob/master/TODO/ux-infinite-scrolling-vs-pagination.md</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;分页是开发中最常见的需求之一。&lt;br&gt;对于分页，我们讨论的最多的是后端的数据库分页，这关乎到我们应用程序的性能，也是分页这个需求的核心。&lt;b
    
    </summary>
    
      <category term="javascript" scheme="http://scarletsky.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://scarletsky.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>自定义 Redux 中的 combineReducers</title>
    <link href="http://scarletsky.github.io/2016/08/20/write-your-own-combine-reducers-in-redux/"/>
    <id>http://scarletsky.github.io/2016/08/20/write-your-own-combine-reducers-in-redux/</id>
    <published>2016-08-20T12:05:28.000Z</published>
    <updated>2016-08-24T03:42:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Redux 中的 <code>combineReducers</code> 能让我们很方便地把多个 reducers 组合起来，成为一个新的 reducer。<br>然而，随着我们的应用变得越来越复杂，<code>combineReducers</code> 有可能不能满足我们的需求。<br>正如 Redux 官方文档所说:</p>
<blockquote>
<p>This helper is just a convenience! You can write your own combineReducers that works differently, or even assemble the state object from the child reducers manually and write a root reducing function explicitly, like you would write any other function.</p>
</blockquote>
<p><code>combineReducers</code> 只是方便我们使用而已，我们可以自定义一个完全不同的 <code>combineReducers</code> 来满足我们特殊的需求。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>我们先回忆一下 reducer 的写法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">oldState, action</span>) =&gt;</span> newState;</div></pre></td></tr></table></figure>
<p>reducer 是一个普通的函数，接受两个参数：<code>oldState</code> 和 <code>action</code>，然后返回一个 <code>newState</code>。<br>为了把多个 reducers 组合起来，我们通常会用 Redux 自带的 <code>combineReducers</code> 来实现:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> rootReducer = combineReducers(&#123;</div><div class="line">  <span class="attr">key1</span>: key1Reducer,</div><div class="line">  <span class="attr">key2</span>: key2Reducer</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>先留意一下我们传了什么给 <code>combineReducers</code>:<br><figure class="highlight js"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">key1</span>: <span class="function"><span class="keyword">function</span>(<span class="params">state.key1, action</span>) </span>&#123; <span class="comment">/*...*/</span> &#125;,</div><div class="line">  <span class="attr">key2</span>: <span class="function"><span class="keyword">function</span>(<span class="params">state.key2, action</span>) </span>&#123; <span class="comment">/*...*/</span> &#125;,</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>好了，让我们先来想一想，经过 <code>combineReducers</code> 的处理之后，我们得到了什么呢？<br>不用想了，很显然我们得到了一个新的 reducer。<br>那这个新的 reducer 又长什么样呢？<br><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> rootReducer = <span class="function">(<span class="params">oldState, action</span>) =&gt;</span> newState;</div></pre></td></tr></table></figure></p>
<p>你应该不会惊讶，因为所有 reducer 都长这个样子，即使它是已经被组合过的 reducer，它也是长这个样子。<br>现在你应该猜到 <code>combineReducers</code> 做了什么了吧？其实它最基本形态是这样子的:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">combineReducers</span>(<span class="params">reducers</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">state, action</span>) </span>&#123; <span class="comment">/*...*/</span> &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它接受 <code>reducers</code> 作为参数，然后返回一个标准的 reducer 函数。</p>
<blockquote>
<p>注意:<br>其实到了这一步，我们就可以自定义 <code>combineReducers</code> 了，我们完全可以写一个类似的函数，然后在里面写各种 <code>switch...case</code> 语句来达到自定义的目的。<br>但我觉得我们还是先看看 Redux 自带的 <code>combineReducers</code> 做了什么比较好，因为我们自定义的 <code>combineReducers</code> 很有可能需要原来的功能。</p>
</blockquote>
<p>还记得我刚才叫你留意的地方吗？没错，就是下面这个:<br><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// reducers</span></div><div class="line">&#123;</div><div class="line">  <span class="attr">key1</span>: <span class="function"><span class="keyword">function</span>(<span class="params">state.key1, action</span>) </span>&#123; <span class="comment">/*...*/</span> &#125;,</div><div class="line">  <span class="attr">key2</span>: <span class="function"><span class="keyword">function</span>(<span class="params">state.key2, action</span>) </span>&#123; <span class="comment">/*...*/</span> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们来回想一下 <code>store.dispatch(action)</code> 的过程：当一个 <code>action</code> 触发的时候，所有 reducers 都应该响应这个 <code>action</code>，做出相应的改变，最后返回一个新的 <code>store</code>。<br>对着上面这个结构，我们其实很容易就能写出这样的效果，还能加上一些其他的处理：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">reCombineReducers</span>(<span class="params">reducers</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">state, action</span>) </span>&#123;</div><div class="line">    <span class="keyword">switch</span> (action.type) &#123;</div><div class="line">      <span class="keyword">case</span> SP_ACTION:</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123; <span class="comment">/* do something */</span> &#125;);</div><div class="line">      <span class="keyword">default</span>:</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.keys(reducers)</div><div class="line">                    .map(<span class="function"><span class="params">k</span> =&gt;</span> (&#123; [k]: reducers[k](state[k], action) &#125;))</div><div class="line">                    .reduce(<span class="function">(<span class="params">prev, next</span>) =&gt;</span> <span class="built_in">Object</span>.assign(&#123;&#125;, prev, next));</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的例子模拟了原来 <code>combineReducers</code> 的功能，还对 <code>SP_ACTION</code> 进行了特殊的处理，很简单吧！</p>
<p>然而，上面的例子虽然模拟了 <code>combineReducers</code> 的功能，但失去了 <code>combineReducers</code> 的检查对象变化的功能，因为现在的 default block 中会返回一个全新的对象。<br>有没有方法可以既保留 <code>combineReducers</code> 的全部功能，又能扩展它呢？<br>其实很简单，我们只要利用 <code>combineReducers</code> 返回的函数就可以了！<br>(感谢 liximomo 指出上面例子中的缺陷)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">reCombineReducers</span>(<span class="params">reducers</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> fn = combineReducers(reducers);</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">state, action</span>) </span>&#123;</div><div class="line">    <span class="keyword">switch</span> (action.type) &#123;</div><div class="line">      <span class="keyword">case</span> SP_ACTION:</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123; <span class="comment">/* do something */</span> &#125;);</div><div class="line">      <span class="keyword">default</span>:</div><div class="line">        <span class="keyword">return</span> fn(state, action);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>按照 Redux 的原则，不同的 reducer 应该相互独立的，它们之间不应该有任何依赖。<br>这个原则看着是很美好的，但在实际使用中还是会有一些例外的情况。<br>一个很简单的例子，也是我遇到过的例子，就是实现一个简单的表格 (其实我的情况复杂的多，需要实现类似 Excel 那样的操作，同时支持其他额外的功能)。<br>我们先来设计一下 <code>state</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// state</span></div><div class="line">&#123;</div><div class="line">  <span class="attr">rows</span>: &#123; ... &#125;,</div><div class="line">  <span class="attr">cells</span>: &#123; ... &#125;,</div><div class="line">  <span class="attr">data</span>: &#123; ... &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>rows</code>, <code>cells</code>, <code>data</code> 都会响应一些特定的 <code>action</code> (如 <code>CHANGE_ROW_PROPS</code>, <code>CHANGE_CELL_PROPS</code>, <code>CHANGE_DATA</code>)，做出相应的改变，这些都是我们所期望的。<br>然而，当出现一些特殊的 action (如 <code>GET_TABLE_SUCCESS</code>，表示成功从服务端获取数据) 的时候，灾难就出现了：<br>所有的 reducer 都需要监听 <code>GET_TABLE_SUCCESS</code> 这个 action，这意味着如果我们有 n 个 reducer 的话，我们就需要修改 n 个文件！<br>当我再加上 <code>UPDATE_TABLE_SUCCESS</code>，<code>REMOVE_TABLE_SUCCESS</code> 之类的 <code>action</code> 时，我要再修改 n 个文件！<br>这不合理啊，为什么我加一个简单的功能，需要修改这么多文件，最重要的是，这些修改都是非常类似！</p>
<p>这时候，我们就需要自定义 <code>combineReducers</code> 来解决我们的需求拉：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">reCombineReducers</span>(<span class="params">reducers</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> fn = combineReducers(reducers);</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">state, action</span>) </span>&#123;</div><div class="line">    <span class="keyword">switch</span> (action.type) &#123;</div><div class="line">      <span class="keyword">case</span> GET_TABLE_SUCCESS:</div><div class="line">      <span class="keyword">case</span> UPDATE_TABLE_SUCCESS:</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, action.payload.table);</div><div class="line">      <span class="keyword">case</span> REMOVE_TABLE_SUCCESS:</div><div class="line">        <span class="keyword">return</span> initState;</div><div class="line">      <span class="keyword">default</span>:</div><div class="line">        <span class="keyword">return</span> fn(state, action);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> table = reCombineReducers(&#123;</div><div class="line">  sections,</div><div class="line">  suites,</div><div class="line">  rows,</div><div class="line">  cells,</div><div class="line">  toys,</div><div class="line">  data,</div><div class="line">  logics</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>怎么样，是不是比修改多个文件舒服很多？</p>
<p>(完)</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://redux.js.org/docs/api/combineReducers.html" target="_blank" rel="external">http://redux.js.org/docs/api/combineReducers.html</a><br><a href="https://github.com/reactjs/redux/blob/master/src/combineReducers.js" target="_blank" rel="external">https://github.com/reactjs/redux/blob/master/src/combineReducers.js</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Redux 中的 &lt;code&gt;combineReducers&lt;/code&gt; 能让我们很方便地把多个 reducers 组合起来，成为一个新的
    
    </summary>
    
      <category term="javascript" scheme="http://scarletsky.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://scarletsky.github.io/tags/javascript/"/>
    
      <category term="redux" scheme="http://scarletsky.github.io/tags/redux/"/>
    
  </entry>
  
  <entry>
    <title>用 GitLab CI 进行持续集成</title>
    <link href="http://scarletsky.github.io/2016/07/29/use-gitlab-ci-for-continuous-integration/"/>
    <id>http://scarletsky.github.io/2016/07/29/use-gitlab-ci-for-continuous-integration/</id>
    <published>2016-07-29T01:22:20.000Z</published>
    <updated>2016-07-30T06:05:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>从 GitLab 8.0 开始，GitLab CI 就已经集成在 GitLab 中，我们只要在项目中添加一个 <code>.gitlab-ci.yml</code> 文件，然后添加一个 Runner，即可进行持续集成。 而且随着 GitLab 的升级，GitLab CI 变得越来越强大，本文将介绍如何使用 GitLab CI 进行持续集成。</p>
<h1 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h1><p>在介绍 GitLab CI 之前，我们先看看一些持续集成相关的概念。</p>
<h2 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h2><p>一次 Pipeline 其实相当于一次构建任务，里面可以包含多个流程，如安装依赖、运行测试、编译、部署测试服务器、部署生产服务器等流程。<br>任何提交或者 Merge Request 的合并都可以触发 Pipeline，如下图所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">+------------------+           +----------------+</div><div class="line">|                  |  trigger  |                |</div><div class="line">|   Commit / MR    +----------&gt;+    Pipeline    |</div><div class="line">|                  |           |                |</div><div class="line">+------------------+           +----------------+</div></pre></td></tr></table></figure>
<h2 id="Stages"><a href="#Stages" class="headerlink" title="Stages"></a>Stages</h2><p>Stages 表示构建阶段，说白了就是上面提到的流程。<br>我们可以在一次 Pipeline 中定义多个 Stages，这些 Stages 会有以下特点：</p>
<ul>
<li>所有 Stages 会按照顺序运行，即当一个 Stage 完成后，下一个 Stage 才会开始</li>
<li>只有当所有 Stages 完成后，该构建任务 (Pipeline) 才会成功</li>
<li>如果任何一个 Stage 失败，那么后面的 Stages 不会执行，该构建任务 (Pipeline) 失败</li>
</ul>
<p>因此，Stages 和 Pipeline 的关系就是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">+--------------------------------------------------------+</div><div class="line">|                                                        |</div><div class="line">|  Pipeline                                              |</div><div class="line">|                                                        |</div><div class="line">|  +-----------+     +------------+      +------------+  |</div><div class="line">|  |  Stage 1  |----&gt;|   Stage 2  |-----&gt;|   Stage 3  |  |</div><div class="line">|  +-----------+     +------------+      +------------+  |</div><div class="line">|                                                        |</div><div class="line">+--------------------------------------------------------+</div></pre></td></tr></table></figure>
<h2 id="Jobs"><a href="#Jobs" class="headerlink" title="Jobs"></a>Jobs</h2><p>Jobs 表示构建工作，表示某个 Stage 里面执行的工作。<br>我们可以在 Stages 里面定义多个 Jobs，这些 Jobs 会有以下特点：</p>
<ul>
<li>相同 Stage 中的 Jobs 会并行执行</li>
<li>相同 Stage 中的 Jobs 都执行成功时，该 Stage 才会成功</li>
<li>如果任何一个 Job 失败，那么该 Stage 失败，即该构建任务 (Pipeline) 失败</li>
</ul>
<p>所以，Jobs 和 Stage 的关系图就是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">+------------------------------------------+</div><div class="line">|                                          |</div><div class="line">|  Stage 1                                 |</div><div class="line">|                                          |</div><div class="line">|  +---------+  +---------+  +---------+   |</div><div class="line">|  |  Job 1  |  |  Job 2  |  |  Job 3  |   |</div><div class="line">|  +---------+  +---------+  +---------+   |</div><div class="line">|                                          |</div><div class="line">+------------------------------------------+</div></pre></td></tr></table></figure>
<h1 id="GitLab-Runner"><a href="#GitLab-Runner" class="headerlink" title="GitLab Runner"></a>GitLab Runner</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>理解了上面的基本概念之后，有没有觉得少了些什么东西 —— 由谁来执行这些构建任务呢？<br>答案就是 GitLab Runner 了！</p>
<p>想问为什么不是 GitLab CI 来运行那些构建任务？<br>一般来说，构建任务都会占用很多的系统资源 (譬如编译代码)，而 GitLab CI 又是 GitLab 的一部分，如果由 GitLab CI 来运行构建任务的话，在执行构建任务的时候，GitLab 的性能会大幅下降。</p>
<p>GitLab CI 最大的作用是管理各个项目的构建状态，因此，运行构建任务这种浪费资源的事情就交给 GitLab Runner 来做拉！<br>因为 GitLab Runner 可以安装到不同的机器上，所以在构建任务运行期间并不会影响到 GitLab 的性能~</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装 GitLab Runner 太简单了，按照着 <a href="https://gitlab.com/gitlab-org/gitlab-ci-multi-runner" target="_blank" rel="external">官方文档</a> 的教程来就好拉！<br>下面是 Debian/Ubuntu/CentOS 的安装方法，其他系统去参考官方文档：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># For Debian/Ubuntu</span></div><div class="line">$ curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-ci-multi-runner/script.deb.sh | sudo bash</div><div class="line">$ sudo apt-get install gitlab-ci-multi-runner</div><div class="line"></div><div class="line"><span class="comment"># For CentOS</span></div><div class="line">$ curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-ci-multi-runner/script.rpm.sh | sudo bash</div><div class="line">$ sudo yum install gitlab-ci-multi-runner</div></pre></td></tr></table></figure>
<h2 id="注册-Runner"><a href="#注册-Runner" class="headerlink" title="注册 Runner"></a>注册 Runner</h2><p>安装好 GitLab Runner 之后，我们只要启动 Runner 然后和 CI 绑定就可以了：</p>
<ul>
<li>打开你 GitLab 中的项目页面，在项目设置中找到 runners</li>
<li>运行 <code>sudo gitlab-ci-multi-runner register</code></li>
<li>输入 CI URL</li>
<li>输入 Token</li>
<li>输入 Runner 的名字</li>
<li>选择 Runner 的类型，简单起见还是选 Shell 吧</li>
<li>完成</li>
</ul>
<p>当注册好 Runner 之后，可以用 <code>sudo gitlab-ci-multi-runner list</code> 命令来查看各个 Runner 的状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ sudo gitlab-runner list</div><div class="line">Listing configured runners          ConfigFile=/etc/gitlab-runner/config.toml</div><div class="line">my-runner                           Executor=shell Token=<span class="built_in">cd</span>1<span class="built_in">cd</span>7cf243afb47094677855aacd3 URL=http://mygitlab.com/ci</div></pre></td></tr></table></figure>
<h1 id="gitlab-ci-yml"><a href="#gitlab-ci-yml" class="headerlink" title=".gitlab-ci.yml"></a>.gitlab-ci.yml</h1><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><p>配置好 Runner 之后，我们要做的事情就是在项目根目录中添加 <code>.gitlab-ci.yml</code> 文件了。<br>当我们添加了 <code>.gitlab-ci.yml</code> 文件后，每次提交代码或者合并 MR 都会自动运行构建任务了。</p>
<p>还记得 Pipeline 是怎么触发的吗？Pipeline 也是通过提交代码或者合并 MR 来触发的！<br>那么 Pipeline 和 <code>.gitlab-ci.yml</code> 有什么关系呢？<br>其实 <code>.gitlab-ci.yml</code> 就是在定义 Pipeline 而已拉！</p>
<h2 id="基本写法"><a href="#基本写法" class="headerlink" title="基本写法"></a>基本写法</h2><p>我们先来看看 <code>.gitlab-ci.yml</code> 是怎么写的：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 定义 stages</span></div><div class="line"><span class="attr">stages:</span></div><div class="line"><span class="bullet">  -</span> build</div><div class="line"><span class="bullet">  -</span> test</div><div class="line"></div><div class="line"><span class="comment"># 定义 job</span></div><div class="line"><span class="attr">job1:</span></div><div class="line"><span class="attr">  stage:</span> test</div><div class="line"><span class="attr">  script:</span></div><div class="line"><span class="bullet">    -</span> echo <span class="string">"I am job1"</span></div><div class="line"><span class="bullet">    -</span> echo <span class="string">"I am in test stage"</span></div><div class="line"></div><div class="line"><span class="comment"># 定义 job</span></div><div class="line"><span class="attr">job2:</span></div><div class="line"><span class="attr">  stage:</span> build</div><div class="line"><span class="attr">  script:</span></div><div class="line"><span class="bullet">    -</span> echo <span class="string">"I am job2"</span></div><div class="line"><span class="bullet">    -</span> echo <span class="string">"I am in build stage"</span></div></pre></td></tr></table></figure>
<p>写起来很简单吧！用 <code>stages</code> 关键字来定义 Pipeline 中的各个构建阶段，然后用一些非关键字来定义 jobs。<br>每个 job 中可以可以再用 <code>stage</code> 关键字来指定该 job 对应哪个 stage。<br>job 里面的 <code>script</code> 关键字是最关键的地方了，也是每个 job 中必须要包含的，它表示每个 job 要执行的命令。</p>
<p>回想一下我们之前提到的 Stages 和 Jobs 的关系，然后猜猜上面例子的运行结果？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">I am job2</div><div class="line">I am in build stage</div><div class="line">I am job1</div><div class="line">I am in test stage</div></pre></td></tr></table></figure>
<p>根据我们在 <code>stages</code> 中的定义，<code>build</code> 阶段要在 <code>test</code> 阶段之前运行，所以 <code>stage:build</code> 的 jobs 会先运行，之后才会运行 <code>stage:test</code> 的 jobs。</p>
<h2 id="常用的关键字"><a href="#常用的关键字" class="headerlink" title="常用的关键字"></a>常用的关键字</h2><p>下面介绍一些常用的关键字，想要更加详尽的内容请前往 <a href="http://docs.gitlab.com/ce/ci/yaml/README.html" target="_blank" rel="external">官方文档</a></p>
<h3 id="stages"><a href="#stages" class="headerlink" title="stages"></a>stages</h3><p>定义 Stages，默认有三个 Stages，分别是 <code>build</code>, <code>test</code>, <code>deploy</code>。</p>
<h3 id="types"><a href="#types" class="headerlink" title="types"></a>types</h3><p><code>stages</code> 的别名。</p>
<h3 id="before-script"><a href="#before-script" class="headerlink" title="before_script"></a>before_script</h3><p>定义任何 Jobs 运行前都会执行的命令。</p>
<h3 id="after-script"><a href="#after-script" class="headerlink" title="after_script"></a>after_script</h3><blockquote>
<p>要求 GitLab 8.7+ 和 GitLab Runner 1.2+</p>
</blockquote>
<p>定义任何 Jobs 运行完后都会执行的命令。</p>
<h3 id="variables-amp-amp-Job-variables"><a href="#variables-amp-amp-Job-variables" class="headerlink" title="variables &amp;&amp; Job.variables"></a>variables &amp;&amp; Job.variables</h3><blockquote>
<p>要求 GitLab Runner 0.5.0+</p>
</blockquote>
<p>定义环境变量。<br>如果定义了 Job 级别的环境变量的话，该 Job 会优先使用 Job 级别的环境变量。</p>
<h3 id="cache-amp-amp-Job-cache"><a href="#cache-amp-amp-Job-cache" class="headerlink" title="cache &amp;&amp; Job.cache"></a>cache &amp;&amp; Job.cache</h3><blockquote>
<p>要求 GitLab Runner 0.7.0+</p>
</blockquote>
<p>定义需要缓存的文件。<br>每个 Job 开始的时候，Runner 都会删掉 <code>.gitignore</code> 里面的文件。<br>如果有些文件 (如 <code>node_modules/</code>) 需要多个 Jobs 共用的话，我们只能让每个 Job 都先执行一遍 <code>npm install</code>。<br>这样很不方便，因此我们需要对这些文件进行缓存。缓存了的文件除了可以跨 Jobs 使用外，还可以跨 Pipeline 使用。</p>
<p>具体用法请查看 <a href="http://docs.gitlab.com/ce/ci/yaml/README.html#cache" target="_blank" rel="external">官方文档</a>。</p>
<h3 id="Job-script"><a href="#Job-script" class="headerlink" title="Job.script"></a>Job.script</h3><p>定义 Job 要运行的命令，必填项。</p>
<h3 id="Job-stage"><a href="#Job-stage" class="headerlink" title="Job.stage"></a>Job.stage</h3><p>定义 Job 的 stage，默认为 <code>test</code>。</p>
<h3 id="Job-artifacts"><a href="#Job-artifacts" class="headerlink" title="Job.artifacts"></a>Job.artifacts</h3><p>定义 Job 中生成的附件。<br>当该 Job 运行成功后，生成的文件可以作为附件 (如生成的二进制文件) 保留下来，打包发送到 GitLab，之后我们可以在 GitLab 的项目页面下下载该附件。<br>注意，不要把 <code>artifacts</code> 和 <code>cache</code> 混淆了。</p>
<h2 id="实用例子"><a href="#实用例子" class="headerlink" title="实用例子"></a>实用例子</h2><p>下面给出一个我自己在用的例子：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><div class="line"><span class="attr">stages:</span></div><div class="line"><span class="bullet">  -</span> install_deps</div><div class="line"><span class="bullet">  -</span> test</div><div class="line"><span class="bullet">  -</span> build</div><div class="line"><span class="bullet">  -</span> deploy_test</div><div class="line"><span class="bullet">  -</span> deploy_production</div><div class="line"></div><div class="line"><span class="attr">cache:</span></div><div class="line"><span class="attr">  key:</span> $&#123;CI_BUILD_REF_NAME&#125;</div><div class="line"><span class="attr">  paths:</span></div><div class="line"><span class="bullet">    -</span> node_modules/</div><div class="line"><span class="bullet">    -</span> dist/</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 安装依赖</span></div><div class="line"><span class="attr">install_deps:</span></div><div class="line"><span class="attr">  stage:</span> install_deps</div><div class="line"><span class="attr">  only:</span></div><div class="line"><span class="bullet">    -</span> develop</div><div class="line"><span class="bullet">    -</span> master</div><div class="line"><span class="attr">  script:</span></div><div class="line"><span class="bullet">    -</span> npm install</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 运行测试用例</span></div><div class="line"><span class="attr">test:</span></div><div class="line"><span class="attr">  stage:</span> test</div><div class="line"><span class="attr">  only:</span></div><div class="line"><span class="bullet">    -</span> develop</div><div class="line"><span class="bullet">    -</span> master</div><div class="line"><span class="attr">  script:</span></div><div class="line"><span class="bullet">    -</span> npm run test</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 编译</span></div><div class="line"><span class="attr">build:</span></div><div class="line"><span class="attr">  stage:</span> build</div><div class="line"><span class="attr">  only:</span></div><div class="line"><span class="bullet">    -</span> develop</div><div class="line"><span class="bullet">    -</span> master</div><div class="line"><span class="attr">  script:</span></div><div class="line"><span class="bullet">    -</span> npm run clean</div><div class="line"><span class="bullet">    -</span> npm run build:client</div><div class="line"><span class="bullet">    -</span> npm run build:server</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 部署测试服务器</span></div><div class="line"><span class="attr">deploy_test:</span></div><div class="line"><span class="attr">  stage:</span> deploy_test</div><div class="line"><span class="attr">  only:</span></div><div class="line"><span class="bullet">    -</span> develop</div><div class="line"><span class="attr">  script:</span></div><div class="line"><span class="bullet">    -</span> pm2 delete app || <span class="literal">true</span></div><div class="line"><span class="bullet">    -</span> pm2 start app.js --name app</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 部署生产服务器</span></div><div class="line"><span class="attr">deploy_production:</span></div><div class="line"><span class="attr">  stage:</span> deploy_production</div><div class="line"><span class="attr">  only:</span></div><div class="line"><span class="bullet">    -</span> master</div><div class="line"><span class="attr">  script:</span></div><div class="line"><span class="bullet">    -</span> bash scripts/deploy/deploy.sh</div></pre></td></tr></table></figure>
<p>上面的配置把一次 Pipeline 分成五个阶段：</p>
<ul>
<li>安装依赖(<code>install_deps</code>)</li>
<li>运行测试(<code>test</code>)</li>
<li>编译(<code>build</code>)</li>
<li>部署测试服务器(<code>deploy_test</code>)</li>
<li>部署生产服务器(<code>deploy_production</code>)</li>
</ul>
<p>设置 <code>Job.only</code> 后，只有当 develop 分支和 master 分支有提交的时候才会触发相关的 Jobs。<br>注意，我这里用 GitLab Runner 所在的服务器作为测试服务器。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://about.gitlab.com/gitlab-ci/" target="_blank" rel="external">https://about.gitlab.com/gitlab-ci/</a><br><a href="http://docs.gitlab.com/ce/ci/yaml/README.html" target="_blank" rel="external">http://docs.gitlab.com/ce/ci/yaml/README.html</a><br><a href="http://docs.gitlab.com/ce/ci/variables/README.html" target="_blank" rel="external">http://docs.gitlab.com/ce/ci/variables/README.html</a><br><a href="https://gitlab.com/gitlab-org/gitlab-ci-multi-runner" target="_blank" rel="external">https://gitlab.com/gitlab-org/gitlab-ci-multi-runner</a><br><a href="https://gitlab.com/gitlab-org/gitlab-ci-multi-runner/issues/1232" target="_blank" rel="external">https://gitlab.com/gitlab-org/gitlab-ci-multi-runner/issues/1232</a><br><a href="http://stackbox.cn/2016-02-gitlab-ci-conf/" target="_blank" rel="external">http://stackbox.cn/2016-02-gitlab-ci-conf/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;从 GitLab 8.0 开始，GitLab CI 就已经集成在 GitLab 中，我们只要在项目中添加一个 &lt;code&gt;.gitlab-c
    
    </summary>
    
    
      <category term="ci" scheme="http://scarletsky.github.io/tags/ci/"/>
    
      <category term="gitlab-ci" scheme="http://scarletsky.github.io/tags/gitlab-ci/"/>
    
  </entry>
  
  <entry>
    <title>Non-deterministic value and List Monad in Haskell</title>
    <link href="http://scarletsky.github.io/2016/07/16/non-determinism-value-and-list-monad-in-haskell/"/>
    <id>http://scarletsky.github.io/2016/07/16/non-determinism-value-and-list-monad-in-haskell/</id>
    <published>2016-07-16T08:01:39.000Z</published>
    <updated>2016-07-16T16:11:07.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>看 《Learn you a haskell for a great good》 这本书的过程中，有时候会看到 <strong>non-determinism</strong> 这个词，虽然具体不知道什么意思，但不影响阅读，所以就没深究。<br>最近看到 List Monad 部分的时候，这个词的出现频率比以前高得多。这时候我才留意到，<strong>non-determinism</strong> 之前也是在 List 相关的地方出现的。<br>那么，<strong>non-determinism</strong> 到底指的是什么呢？</p>
<h2 id="deterministic-value-与-non-deterministic-value"><a href="#deterministic-value-与-non-deterministic-value" class="headerlink" title="deterministic value 与 non-deterministic value"></a>deterministic value 与 non-deterministic value</h2><p>在理解 <strong>non-deterministic value</strong> 之前，我们先看看什么是 <strong>deterministic value</strong>。</p>
<p>从字面意思推测，<strong>deterministic value</strong> 是确定的值，那确定的值到底是什么呢？书中有这么一段话：</p>
<blockquote>
<p>A value like 5 is deterministic. It has only one result and we know exactly what it is. On the other hand, a value like [3,8,9] contains several results, so we can view it as one value that is actually many values at the same time.</p>
</blockquote>
<p>像 5 这种只表示一种结果的值，它就是确定的值。<br>像 [3,8,9] 那样，它包含了多个值，我们可以把它看成是用一个值来表示多个结果，例如它可以表示 3，也可以表示 8，也可以表示 9，因此它是非确定值。</p>
<p><strong>deterministic value</strong> 和 <strong>non-deterministic value</strong> 的区别就在这里。</p>
<p>那么 <strong>non-deterministic value</strong> 到底有什么用呢？<br>我们知道了它可以表示多个结果，那么在动态计算的时候就很方便了，先看看下面这个简单的例子：</p>
<figure class="highlight hs"><table><tr><td class="code"><pre><div class="line"><span class="title">do</span></div><div class="line">  x &lt;- [<span class="number">1</span>,<span class="number">2</span>]</div><div class="line">  y &lt;- [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</div><div class="line">  return (x + y)</div></pre></td></tr></table></figure>
<p>因为 <code>x</code> 可以 1 或者 2， <code>y</code> 可以表示 4 或者 5 或者 6，所以 <code>x+y</code> 就可以表示出 <code>1+4</code>, <code>1+5</code>, <code>1+6</code>, <code>2+4</code>, <code>2+5</code>, <code>2+6</code> 这么多结果了！</p>
<h2 id="List-Monad"><a href="#List-Monad" class="headerlink" title="List Monad"></a>List Monad</h2><p>理解了 <strong>non-deterministic value</strong> 之后，我们再来看看 List Monad。<br>我们知道，不同的 Monad 带有不同的 context，如 Maybe Monad 带有可能失败的 context，那 List Monad 带有怎样的 context 呢？<br>答案就是 <strong>non-determinism</strong>。</p>
<p>先看看 List Monad 的定义：</p>
<figure class="highlight hs"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monad</span> [] <span class="keyword">where</span></span></div><div class="line">  return x = [x]</div><div class="line">  xs &gt;&gt;= f = concat (map f xs)</div><div class="line">  fail _ []</div></pre></td></tr></table></figure>
<p>我们主要看看 <code>&gt;&gt;=</code> 的实现，它把 f 应用到 List 中的每个元素中，然后再把结果扁平化而已。<br>虽然看起来很简单，但用起来很强大：</p>
<figure class="highlight hs"><table><tr><td class="code"><pre><div class="line"><span class="comment">-- 1</span></div><div class="line"><span class="title">ghci</span>&gt; [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] &gt;&gt;= \x -&gt; [x,-x]  </div><div class="line">[<span class="number">3</span>,<span class="number">-3</span>,<span class="number">4</span>,<span class="number">-4</span>,<span class="number">5</span>,<span class="number">-5</span>]</div><div class="line"></div><div class="line"><span class="comment">-- 2</span></div><div class="line"><span class="title">ghci</span>&gt; [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] &gt;&gt;= \x -&gt; [x+<span class="number">1</span>] &gt;&gt;= \y -&gt; [y*<span class="number">2</span>]</div><div class="line">[<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>]</div><div class="line"></div><div class="line"><span class="comment">-- 3</span></div><div class="line"><span class="title">ghci</span>&gt; [<span class="number">1</span>,<span class="number">2</span>] &gt;&gt;= \n -&gt; ['a','b'] &gt;&gt;= \ch -&gt; return (n,ch)</div><div class="line">[(<span class="number">1</span>,'a'),(<span class="number">1</span>,'b'),(<span class="number">2</span>,'a'),(<span class="number">2</span>,'b')]</div><div class="line"></div><div class="line"><span class="comment">-- 4</span></div><div class="line"><span class="title">ghci</span>&gt; [ (n, ch) | n &lt;- [<span class="number">1</span>,<span class="number">2</span>], ch &lt;- ['a', 'b'] ]</div><div class="line">[(<span class="number">1</span>,'a'),(<span class="number">1</span>,'b'),(<span class="number">2</span>,'a'),(<span class="number">2</span>,'b')]</div></pre></td></tr></table></figure>
<p>留意最后两个例子，事实上列表推导 (List Comprehension) 只是 List Monad 的一种语法糖而已。</p>
<p>最后提一下一个很炫的技巧：用 <code>filterM</code> 来生成一个列表的幂集 (Power Set)，即该列表中的所有子列表，如：</p>
<figure class="highlight hs"><table><tr><td class="code"><pre><div class="line"><span class="comment">-- [1,2,3] 的幂集就是</span></div><div class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]  </div><div class="line">[<span class="number">1</span>,<span class="number">2</span>]  </div><div class="line">[<span class="number">1</span>,<span class="number">3</span>]  </div><div class="line">[<span class="number">1</span>]  </div><div class="line">[<span class="number">2</span>,<span class="number">3</span>]  </div><div class="line">[<span class="number">2</span>]  </div><div class="line">[<span class="number">3</span>]  </div><div class="line">[]</div></pre></td></tr></table></figure>
<p>利用 <code>filterM</code> 和 List Monad 可以非常轻松地实现幂集：</p>
<figure class="highlight hs"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> Control.Monad</div><div class="line"></div><div class="line"><span class="title">powerset</span> :: [a] -&gt; [[a]]</div><div class="line"><span class="title">powerset</span> xs = filterM (\x -&gt; [ <span class="type">True</span>, <span class="type">False</span> ]) xs</div><div class="line"></div><div class="line"><span class="comment">-- in ghci</span></div><div class="line"><span class="title">ghci</span>&gt; powerset [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</div><div class="line">[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">1</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">2</span>],[<span class="number">3</span>],[]]</div></pre></td></tr></table></figure>
<p>很神奇吧！想知道为什么的话，去看看下面的链接吧：<br><a href="http://stackoverflow.com/questions/28872396/haskells-filterm-with-filterm-x-true-false-1-2-3" target="_blank" rel="external">http://stackoverflow.com/questions/28872396/haskells-filterm-with-filterm-x-true-false-1-2-3</a> </p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://stackoverflow.com/questions/29886852/why-is-the-following-haskell-code-non-deterministic" target="_blank" rel="external">http://stackoverflow.com/questions/29886852/why-is-the-following-haskell-code-non-deterministic</a><br><a href="http://stackoverflow.com/questions/20638893/how-can-non-determinism-be-modeled-with-a-list-monad" target="_blank" rel="external">http://stackoverflow.com/questions/20638893/how-can-non-determinism-be-modeled-with-a-list-monad</a><br><a href="http://learnyoua.haskell.sg/content/zh-cn/ch12/a-fistful-of-monads.html" target="_blank" rel="external">http://learnyoua.haskell.sg/content/zh-cn/ch12/a-fistful-of-monads.html</a><br><a href="http://learnyoua.haskell.sg/content/zh-cn/ch13/for-a-few-monads-more.html" target="_blank" rel="external">http://learnyoua.haskell.sg/content/zh-cn/ch13/for-a-few-monads-more.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;看 《Learn you a haskell for a great good》 这本书的过程中，有时候会看到 &lt;strong&gt;non-de
    
    </summary>
    
      <category term="haskell" scheme="http://scarletsky.github.io/categories/haskell/"/>
    
    
      <category term="haskell" scheme="http://scarletsky.github.io/tags/haskell/"/>
    
  </entry>
  
  <entry>
    <title>如何用 JavaScript 下载文件</title>
    <link href="http://scarletsky.github.io/2016/07/03/download-file-using-javascript/"/>
    <id>http://scarletsky.github.io/2016/07/03/download-file-using-javascript/</id>
    <published>2016-07-03T10:43:41.000Z</published>
    <updated>2016-07-03T10:43:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>我们知道，下载文件是一个非常常见的需求，但由于浏览器的安全策略的限制，我们通常只能通过一个额外的页面，访问某个文件的 url 来实现下载功能，但是这种用户体验非常不好。<br>幸好，HTML 5 里面为 <code>&lt;a&gt;</code> 标签添加了一个 <code>download</code> 的属性，我们可以轻易的利用它来实现下载功能，再也不需要用以前的笨办法了。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>我们先看看 <code>download</code> 的使用方法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://somehost/somefile.zip"</span> <span class="attr">download</span>=<span class="string">"filename.zip"</span>&gt;</span>Download file<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div></pre></td></tr></table></figure>
<p>看看上面的代码，只要为 <code>&lt;a&gt;</code> 标签添加 <code>download</code> 属性，我们点击这个链接的时候就会自动下载文件了~<br>顺便说下，<code>download</code> 的属性值是可选的，它用来指定下载文件的文件名。像上面的例子中，我们下载到本地的文件名就会是 filename.zip 拉，如果不指定的话，它就会是 somefile.zip 这个名字拉！</p>
<p>看到这里，你可能会说，坑爹啊，这明明是用 HTML 5 的新特性来实现下载文件嘛，说好的用 JavaScript 下载文件呢？</p>
<p>事实上，用 JavaScript 来下载文件也是利用这一特性来实现的，我们的 JavaScript 代码不外乎就是：</p>
<ul>
<li>用 JavaScript 创建一个隐藏的 <code>&lt;a&gt;</code> 标签</li>
<li>设置它的 <code>href</code> 属性</li>
<li>设置它的 <code>download</code> 属性</li>
<li>用 JavaScript 来触发这个它的 <code>click</code> 事件</li>
</ul>
<p>翻译成 JavaScript 代码就是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>);</div><div class="line"><span class="keyword">var</span> url = <span class="built_in">window</span>.URL.createObjectURL(blob);</div><div class="line"><span class="keyword">var</span> filename = <span class="string">'what-you-want.txt'</span>;</div><div class="line">a.href = url;</div><div class="line">a.download = filename;</div><div class="line">a.click();</div><div class="line"><span class="built_in">window</span>.URL.revokeObjectURL(url);</div></pre></td></tr></table></figure>
<p>好拉，是不是看到有个陌生的东东呢？</p>
<h2 id="window-URL"><a href="#window-URL" class="headerlink" title="window.URL"></a>window.URL</h2><p><code>window.URL</code> 里面有两个方法： </p>
<ul>
<li><code>createObjectURL</code> 用 blob 对象来创建一个 object URL(它是一个 <code>DOMString</code>)，我们可以用这个 object URL 来表示某个 blob 对象，这个 object URL 可以用在 <code>href</code> 和 <code>src</code> 之类的属性上。</li>
<li><code>revokeObjectURL</code> 释放由 <code>createObjectURL</code> 创建的 object URL，当该 object URL 不需要的时候，我们要主动调用这个方法来获取最佳性能和内存使用。</li>
</ul>
<p>知道了这两个方法之后，我们再回去看看上面的例子就很容易理解了吧！只是用 blob 对象来创建一条 URL，然后让 <code>&lt;a&gt;</code> 标签引用该 URL，然后触发个点击事件，就可以下载文件了！</p>
<p>那么问题来了，blob 对象哪里来？</p>
<h2 id="Blob-对象"><a href="#Blob-对象" class="headerlink" title="Blob 对象"></a>Blob 对象</h2><p>Blob 全称是 Binary large object，它表示一个类文件对象，可以用它来表示一个文件。根据 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Blob" target="_blank" rel="external">MDN</a> 上面的说法，<code>File API</code> 也是基于 blob 来实现的。</p>
<p>由于本文的主题是讲 JavaScript 下载文件，那我们构建 blob 的方式就是通过服务器返回的文件来创建 blob 拉！<br>而最简单的方式就是用 <code>fetch API</code> 了，我们可以整合上面的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">fetch(<span class="string">'http://somehost/somefile.zip'</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> res.blob().then(<span class="function"><span class="params">blob</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">var</span> a = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>);</div><div class="line">    <span class="keyword">var</span> url = <span class="built_in">window</span>.URL.createObjectURL(blob);</div><div class="line">    <span class="keyword">var</span> filename = <span class="string">'myfile.zip'</span>;</div><div class="line">    a.href = url;</div><div class="line">    a.download = filename;</div><div class="line">    a.click();</div><div class="line">    <span class="built_in">window</span>.URL.revokeObjectURL(url);</div><div class="line">&#125;))</div></pre></td></tr></table></figure>
<p>很简单对吧！</p>
<p>你可能会问，何必这么麻烦呢？直接写成下面这样不就好了：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://somehost/somefile.zip"</span> <span class="attr">download</span>=<span class="string">"myfile.zip"</span>&gt;</span>Download file<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div></pre></td></tr></table></figure>
<p>嗯，对于这种写法，我只能说，你做的太正确了！如果你要下载的是已经存在服务器上面的静态文件的话，那么写成这样是最方便的。浏览器会帮你处理整个下载过程，不需要你干涉。如果你用 blob 的方式来下载文件的话，会有下面这些限制的：</p>
<h3 id="限制一：不同浏览器对-blob-对象有不同的限制"><a href="#限制一：不同浏览器对-blob-对象有不同的限制" class="headerlink" title="限制一：不同浏览器对 blob 对象有不同的限制"></a>限制一：不同浏览器对 blob 对象有不同的限制</h3><p>具体看看下面这个表格（出自 <a href="https://github.com/eligrey/FileSaver.js#supported-browsers" target="_blank" rel="external">FileSaver.js</a>）：</p>
<table>
<thead>
<tr>
<th>Browser</th>
<th>Constructs as</th>
<th>Filenames</th>
<th>Max Blob Size</th>
<th>Dependencies</th>
</tr>
</thead>
<tbody>
<tr>
<td>Firefox 20+</td>
<td>Blob</td>
<td>Yes</td>
<td>800 MiB</td>
<td>None</td>
</tr>
<tr>
<td>Firefox &lt; 20</td>
<td>data: URI</td>
<td>No</td>
<td>n/a</td>
<td><a href="https://github.com/eligrey/Blob.js" target="_blank" rel="external">Blob.js</a></td>
</tr>
<tr>
<td>Chrome</td>
<td>Blob</td>
<td>Yes</td>
<td>500 MiB</td>
<td>None</td>
</tr>
<tr>
<td>Chrome for Android</td>
<td>Blob</td>
<td>Yes</td>
<td>500 MiB</td>
<td>None</td>
</tr>
<tr>
<td>Edge</td>
<td>Blob</td>
<td>Yes</td>
<td>?</td>
<td>None</td>
</tr>
<tr>
<td>IE 10+</td>
<td>Blob</td>
<td>Yes</td>
<td>600 MiB</td>
<td>None</td>
</tr>
<tr>
<td>Opera 15+</td>
<td>Blob</td>
<td>Yes</td>
<td>500 MiB</td>
<td>None</td>
</tr>
<tr>
<td>Opera &lt; 15</td>
<td>data: URI</td>
<td>No</td>
<td>n/a</td>
<td><a href="https://github.com/eligrey/Blob.js" target="_blank" rel="external">Blob.js</a></td>
</tr>
<tr>
<td>Safari 6.1+*</td>
<td>Blob</td>
<td>No</td>
<td>?</td>
<td>None</td>
</tr>
<tr>
<td>Safari &lt; 6</td>
<td>data: URI</td>
<td>No</td>
<td>n/a</td>
<td><a href="https://github.com/eligrey/Blob.js" target="_blank" rel="external">Blob.js</a></td>
</tr>
</tbody>
</table>
<h3 id="限制二：构建完-blob-对象后才会转换成文件"><a href="#限制二：构建完-blob-对象后才会转换成文件" class="headerlink" title="限制二：构建完 blob 对象后才会转换成文件"></a>限制二：构建完 blob 对象后才会转换成文件</h3><p>这一点限制对小文件(几十kb)可能没什么影响，但对稍微大一点的文件影响就很大了。试想，用户要下载一个 100mb 的文件，如果他点击了下载按钮之后没看到下载提示的话，他肯定会继续按，等他按了几次之后还没看到下载提示时，他就会抱怨我们的网站，然后离开了。</p>
<p>然而事实上下载的的确确发生了，只是要等到下载完文件之后才能构建 blob 对象，再转化成文件。而且，用户再触发多几次下载就会造成一些资源上的浪费。</p>
<p>因此，如果是要下载大文件的话，还是推荐直接创建一个 <code>&lt;a&gt;</code> 标签拉~<br>写 html 也好，写 JavaScript 动态创建也好，用自己喜欢的方式去创建就好了。</p>
<h2 id="为什么要用-JavaScript-下载文件"><a href="#为什么要用-JavaScript-下载文件" class="headerlink" title="为什么要用 JavaScript 下载文件"></a>为什么要用 JavaScript 下载文件</h2><p>好拉，说了半天，其实我们一直说的都是：「不要用 JavaScript 下载文件拉，限制多多，又不好用，直接用 html 就好拉，简单方便又快捷」这个论调。<br>事实上也确实如此，但有些时候我们确实需要通过 JavaScript 来做一些<strong>预</strong>处理。</p>
<h3 id="权限校验"><a href="#权限校验" class="headerlink" title="权限校验"></a>权限校验</h3><p>有些时候，我们需要对下载做一些限制，最常见的就是权限校验了，如检查该用户是否有下载的权限，是否有高速下载的权限等等。这时候，我们可以利用 JavaScript 做一些预处理。如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">fetch(<span class="string">'http://somehost/check-permission'</span>, options).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">if</span> (res.code === <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">var</span> a = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>);</div><div class="line">        <span class="keyword">var</span> url = res.data.url;</div><div class="line">        <span class="keyword">var</span> filename = <span class="string">'myfile.zip'</span>;</div><div class="line">        a.href = url;</div><div class="line">        a.download = filename;</div><div class="line">        a.click();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        alert(<span class="string">'You have no permission to download the file!'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在这个例子里面，我们没有用 blob 来构建 URL，而是通过后端服务器来计算出用户的下载链接，然后再利用之前提到的动态创建 <code>&lt;a&gt;</code> 标签的方式来实现下载，很简单吧！</p>
<h3 id="动态文件"><a href="#动态文件" class="headerlink" title="动态文件"></a>动态文件</h3><p>动态生成文件然后返回给客户端也是一个很常见的需求，譬如我们有时候需要做导出数据的功能，把数据库中的某些数据导出到 Excel 中，然后再返回客户端。<br>这时候我们就不能简单的指定 <code>href</code> 属性，因为对应的 URL 并不存在。<br>我们只能通过 JavaScript 对服务器发出一个请求，通知它去生成某个文件，然后把对应的 URL 返回给客户端。<br>有没有感觉这个过程和上面「权限校验」一节很像？肯定拉，因为我们只是对 URL 做了一些预处理而已嘛~</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>由于 <code>download</code> 属性是 HTML 5 的新特性，因此它不支持旧版本的浏览器。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>HTML 5 新的 <code>download</code> 特性真的很好用，结合 JavaScript 的动态能力我们可以很方便的做出复杂的下载功能~</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/eligrey/FileSaver.js/blob/master/FileSaver.js" target="_blank" rel="external">https://github.com/eligrey/FileSaver.js/blob/master/FileSaver.js</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL" target="_blank" rel="external">https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/API/Blob" target="_blank" rel="external">https://developer.mozilla.org/en-US/docs/Web/API/Blob</a><br><a href="http://stackoverflow.com/questions/19327749/javascript-blob-filename-without-link" target="_blank" rel="external">http://stackoverflow.com/questions/19327749/javascript-blob-filename-without-link</a><br><a href="http://stackoverflow.com/questions/24501358/how-to-set-a-header-for-a-http-get-request-and-trigger-file-download" target="_blank" rel="external">http://stackoverflow.com/questions/24501358/how-to-set-a-header-for-a-http-get-request-and-trigger-file-download</a><br><a href="http://blog.bguiz.com/2014/07/03/file-download-with-http-request-header/" target="_blank" rel="external">http://blog.bguiz.com/2014/07/03/file-download-with-http-request-header/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;我们知道，下载文件是一个非常常见的需求，但由于浏览器的安全策略的限制，我们通常只能通过一个额外的页面，访问某个文件的 url 来实现下载功能
    
    </summary>
    
      <category term="javascript" scheme="http://scarletsky.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://scarletsky.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>「译」Node.js Streams 基础</title>
    <link href="http://scarletsky.github.io/2016/07/01/basics-node-js-streams/"/>
    <id>http://scarletsky.github.io/2016/07/01/basics-node-js-streams/</id>
    <published>2016-07-01T05:45:12.000Z</published>
    <updated>2016-07-02T13:51:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>Node.js 天生异步和事件驱动，非常适合处理 I/O 相关的任务。如果你在处理应用中 I/O 相关的操作，你可以利用 Node.js 中的流(stream)。因此，我们先具体看看流，理解一下它们是怎么简化 I/O 操作的吧。</p>
<h2 id="流是什么"><a href="#流是什么" class="headerlink" title="流是什么"></a>流是什么</h2><p>流是 unix 管道，让你可以很容易地从数据源读取数据，然后流向另一个目的地。<br>简单来说，流不是什么特别的东西，它只是一个实现了一些方法的 <code>EventEmitter</code>。根据它实现的方法，流可以变成可读流(Readable)，可写流(Writable)，或者双向流(Duplex，同时可读可写)。<br>可读流能让你从一个数据源读取数据，而可写流则可以让你往目的地写入数据。</p>
<p>如果你已经用过 Node.js，你很可能已经遇到过流了。<br>例如，在一个 Node.js 的 HTTP 服务器里面，<code>request</code> 是一个可读流，<code>response</code> 是一个可写流。<br>你也可能用过 <code>fs</code> 模块，它能帮你处理可读可写流。</p>
<p>现在让你学一些基础，理解不同类型的流。本文会讨论可读流和可写流，双向流超出了本文的讨论范围，我们不作讨论。</p>
<h2 id="可读流-Readable-Streams"><a href="#可读流-Readable-Streams" class="headerlink" title="可读流 (Readable Streams)"></a>可读流 (Readable Streams)</h2><p>我们可以用可读流从一个数据源中读取数据，这个数据源可以是任何东西，例如系统中的一个文件，内存中的 buffer，甚至是其他流。因为流是 <code>EventEmitter</code>，它们会用各种事件发送数据。我们会利用这些事件来让流工作。</p>
<h3 id="从流中读取数据"><a href="#从流中读取数据" class="headerlink" title="从流中读取数据"></a>从流中读取数据</h3><p>从流中读取数据最好的方式是监听 <code>data</code> 事件，添加一个回调函数。当有数据流过来的时候，可读流会发送 <code>data</code> 事件，回调函数就会触发。看看下面的代码片段：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"><span class="keyword">var</span> readableStream = fs.createReadStream(<span class="string">'file.txt'</span>);</div><div class="line"><span class="keyword">var</span> data = <span class="string">''</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> readableStream.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</div><div class="line">  data += chunk;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">readableStream.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(data);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><code>fs.createReadStream</code> 会给你一个可读流。<br>最开始的时候，这个流不是流动态的。当你添加了 <code>data</code> 的事件监听器，加上一个回调函数时，它才会变成流动态的。在这之后，它就会读取一小块数据，然后传到你的回调函数里面。<br>流的实现者决定了 <code>data</code> 事件的触发频率，例如 HTTP request 会在读取到几 KB 数据的时候触发 <code>data</code> 事件。 当你从一个文件中读取数据的时候，你可能会决定当一行被读完的时候就触发 <code>data</code> 事件。</p>
<p>当没有数据可读的时候 (读到文件尾部时)，流就会发送 <code>end</code> 事件。在上面的例子中，我们监听了这个事件，当读完文件的时候，就把数据打印出来。</p>
<p>还有另一种读取流的方式，你只要在读到文件尾部前不断调用流实例中的 <code>read()</code> 方法就可以了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"><span class="keyword">var</span> readableStream = fs.createReadStream(<span class="string">'file.txt'</span>);</div><div class="line"><span class="keyword">var</span> data = <span class="string">''</span>;</div><div class="line"><span class="keyword">var</span> chunk;</div><div class="line"></div><div class="line">readableStream.on(<span class="string">'readable'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">while</span> ((chunk = readableStream.read()) != <span class="literal">null</span>) &#123;</div><div class="line">    data += chunk;</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">readableStream.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(data);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><code>read()</code> 方法会从内部 buffer 中读取数据，当没有数据可读的时候，它会返回 <code>null</code>。<br>因此，在 while 循环中我们检查 <code>read()</code> 是不是返回 <code>null</code>，当它返回 <code>null</code> 的时候，就终止循环。<br>需要注意的是，当我们可以从流中读取数据的时候，<code>readable</code> 事件就会触发。</p>
<h3 id="设置编码"><a href="#设置编码" class="headerlink" title="设置编码"></a>设置编码</h3><p>默认情况下，你从流中读取到的是 <code>Buffer</code> 对象。如果你要读取的是字符串的话，这并不适合你。因此，你可以像下面的例子那样通过调用 <code>Readable.setEncoding()</code> 来设置流的编码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"><span class="keyword">var</span> readableStream = fs.createReadStream(<span class="string">'file.txt'</span>);</div><div class="line"><span class="keyword">var</span> data = <span class="string">''</span>;</div><div class="line"></div><div class="line">readableStream.setEncoding(<span class="string">'utf8'</span>);</div><div class="line"></div><div class="line">readableStream.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</div><div class="line">  data += chunk;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">readableStream.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(data);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上面的例子中，我们把流的编码设置成 <code>utf8</code>，数据就会被解析成 <code>utf8</code>，回调函数中的 <code>chunk</code> 就会是字符串了。</p>
<h3 id="管道-Piping"><a href="#管道-Piping" class="headerlink" title="管道 (Piping)"></a>管道 (Piping)</h3><p>管道是一个很棒的机制，你不需要自己管理流的状态就可以从数据源中读取数据，然后写入到目的地中。我们先看看下面的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"><span class="keyword">var</span> readableStream = fs.createReadStream(<span class="string">'file1.txt'</span>);</div><div class="line"><span class="keyword">var</span> writableStream = fs.createWriteStream(<span class="string">'file2.txt'</span>);</div><div class="line"></div><div class="line">readableStream.pipe(writableStream);</div></pre></td></tr></table></figure>
<p>上面的例子利用 <code>pipe()</code> 方法把 file1 的内容写到 file2 中。因为 <code>pipe()</code> 会帮你管理数据流，你不需要担心数据流的速度。这让 <code>pipe()</code> 变得非常简洁易用。<br>需要注意的是，<code>pipe()</code> 会返回目的地的流，因此你可以很轻易让多个流链接起来！</p>
<h3 id="链接-Chaining"><a href="#链接-Chaining" class="headerlink" title="链接 (Chaining)"></a>链接 (Chaining)</h3><p>假设有一个归档文件，你想要解压它。有很多方式可以完成这个任务。但最简洁的方式是利用管道和链接：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"><span class="keyword">var</span> zlib = <span class="built_in">require</span>(<span class="string">'zlib'</span>);</div><div class="line"></div><div class="line">fs.createReadStream(<span class="string">'input.txt.gz'</span>)</div><div class="line">  .pipe(zlib.createGunzip())</div><div class="line">  .pipe(fs.createWriteStream(<span class="string">'output.txt'</span>));</div></pre></td></tr></table></figure>
<p>首先，我们通过 <code>input.txt.gz</code> 创建了一个可读流，然后让它流向 <code>zlib.createGunzip()</code> 流，它会解压内容。最后，我们添加一个可写流把解压后的内容写到另一个文件中。</p>
<h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><p>我们已经讨论了一些可读流中重要的概念了，这里还有一些你需要知道的方法：</p>
<ol>
<li><code>Readable.pause()</code> - 这个方法会暂停流的流动。换句话说就是它不会再触发 <code>data</code> 事件。</li>
<li><code>Readable.resume()</code> - 这个方法和上面的相反，会让暂停流恢复流动。</li>
<li><code>Readable.unpipe()</code> - 这个方法会把目的地移除。如果有参数传入，它会让可读流停止流向某个特定的目的地，否则，它会移除所有目的地。</li>
</ol>
<h2 id="可写流-Writable-Streams"><a href="#可写流-Writable-Streams" class="headerlink" title="可写流 (Writable Streams)"></a>可写流 (Writable Streams)</h2><p>可写流让你把数据写入目的地。就像可读流那样，这些也是 <code>EventEmitter</code>，它们也会触发不同的事件。我们来看看可写流中会触发的事件和方法吧。</p>
<h3 id="写入流"><a href="#写入流" class="headerlink" title="写入流"></a>写入流</h3><p>要把数据写如到可写流中，你需要在可写流实例中调用 <code>write()</code> 方法，看看下面的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"><span class="keyword">var</span> readableStream = fs.createReadStream(<span class="string">'file1.txt'</span>);</div><div class="line"><span class="keyword">var</span> writableStream = fs.createWriteStream(<span class="string">'file2.txt'</span>);</div><div class="line"></div><div class="line">readableStream.setEncoding(<span class="string">'utf8'</span>);</div><div class="line"></div><div class="line">readableStream.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</div><div class="line">  writableStream.write(<span class="string">'chunk'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上面的代码非常简单，它只是从输入流中读取数据，然后用 <code>write()</code> 写入到目的地中。<br>这个方法返回一个布尔值来表示写入是否成功。如果返回的是 <code>true</code> 那表示写入成功，你可以继续写入更多的数据。 如果是 <code>false</code>，那意味着发生了什么错误，你现在不能继续写入了。可写流会触发一个 <code>drain</code> 事件来告诉你你可以继续写入数据。</p>
<h3 id="写完数据后"><a href="#写完数据后" class="headerlink" title="写完数据后"></a>写完数据后</h3><p>当你不需要在写入数据的时候，你可以调用 <code>end()</code> 方法来告诉流你已经完成写入了。假设 <code>res</code> 是一个 HTTP response 对象，你通常会发送响应给浏览器：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">res.write(<span class="string">'Some Data!!'</span>);</div><div class="line">res.end();</div></pre></td></tr></table></figure>
<p>当 <code>end()</code> 被调用时，所有数据会被写入，然后流会触发一个 <code>finish</code> 事件。注意在调用 <code>end()</code> 之后，你就不能再往可写流中写入数据了。例如下面的代码就会报错：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">res.write(<span class="string">'Some Data!!'</span>);</div><div class="line">res.end();</div><div class="line">res.write(<span class="string">'Trying to write again'</span>); <span class="comment">//Error !</span></div></pre></td></tr></table></figure>
<p>这里有一些和可写流相关的重要事件：</p>
<ol>
<li><code>error</code> - 在写入或链接发生错误时触发</li>
<li><code>pipe</code> - 当可读流链接到可写流时，这个事件会触发</li>
<li><code>unpipe</code> -  在可读流调用 <code>unpipe</code> 时会触发</li>
</ol>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>这些是关于流的基础知识。流，管道，链接是核心，它们是 Node.js 中最强大的功能。如果使用得当，流可以帮助你写出简洁而且高性能的代码。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.sitepoint.com/basics-node-js-streams/" target="_blank" rel="external">https://www.sitepoint.com/basics-node-js-streams/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Node.js 天生异步和事件驱动，非常适合处理 I/O 相关的任务。如果你在处理应用中 I/O 相关的操作，你可以利用 Node.js 中的流(stream)。因此，我们先具体看看流，理解一下它们是怎么简化 I/O 操作的吧。&lt;/p&gt;
&lt;h2 id=&quot;流是什么&quot;&gt;&lt;a h
    
    </summary>
    
      <category term="nodejs" scheme="http://scarletsky.github.io/categories/nodejs/"/>
    
    
      <category term="nodejs" scheme="http://scarletsky.github.io/tags/nodejs/"/>
    
      <category term="stream" scheme="http://scarletsky.github.io/tags/stream/"/>
    
  </entry>
  
  <entry>
    <title>升级 GitLab 过程中踩过的坑</title>
    <link href="http://scarletsky.github.io/2016/06/18/issues-when-upgrading-gitlab/"/>
    <id>http://scarletsky.github.io/2016/06/18/issues-when-upgrading-gitlab/</id>
    <published>2016-06-18T11:58:57.000Z</published>
    <updated>2016-06-20T02:53:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>最近帮公司的 Gitlab 从 7.14 升级到 8.7.6，升级的主要动机是整合 Gitlab CI，提升持续集成的效率。鉴于之前也是我把 Gitlab 从 7.x 升级到 7.14 的，我以为我已经有经验去处理了，但实际上，这次升级让我踩了不少以前没遇到过的坑…<br>本文主要记录升级 Gitlab 过程中踩过的一些坑~</p>
<h2 id="MySQL-突然启动失败"><a href="#MySQL-突然启动失败" class="headerlink" title="MySQL 突然启动失败"></a>MySQL 突然启动失败</h2><p>由于我们公司的 Gitlab 服务器内存不太够，只有 2G，所以偶尔会出现 500 的错误，但通常情况下，直接通过 <code>$ sudo service gitlab restart</code> 重启一次服务就可以恢复正常了。<br>但是，最近我遇到过 gitlab 启动失败，原因是 MySQL 无法启动。<br>当我启动 MySQL 的时候，报了这样的错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ sudo service mysql restart</div><div class="line">...</div><div class="line">MySQL Job failed to start</div></pre></td></tr></table></figure>
<p>报错就报错吧，去看看 error.log 就好了吧。 然而，我太天真了:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ cat /var/log/mysql/error.log</div><div class="line">$ cat /var/log/mysql/mysql.log</div></pre></td></tr></table></figure>
<p>MySQL 的 error.log 是空的，mysql.log 也是空的…太诡异了，没 log 怎么 debug ?<br>还好有万能的 google，我找到了类似情况的问题：<a href="http://stackoverflow.com/questions/22909060/mysql-job-failed-to-start" target="_blank" rel="external">mysql-job-failed-to-start</a>。最高票的答案是重装 mysql 的，但我不敢冒这个风险。我注意到有个回答说：</p>
<blockquote>
<p>The given solution requires enough free HDD</p>
</blockquote>
<p>于是我马上查了一下硬盘空间：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ df -h</div><div class="line">Filesystem      Size  Used Avail Use% Mounted on</div><div class="line">/dev/xvda1       20G   20G  0G   100% /</div><div class="line">...</div></pre></td></tr></table></figure>
<p>原来是空间满了，于是我删掉了一些没用的东西，腾出了 3G 多的空间之后，MySQL 又可以正常启动了，Gitlab 也是！</p>
<h2 id="迁移-MySQL-到-PostgreSQL-时找不到依赖"><a href="#迁移-MySQL-到-PostgreSQL-时找不到依赖" class="headerlink" title="迁移 MySQL 到 PostgreSQL 时找不到依赖"></a>迁移 MySQL 到 PostgreSQL 时找不到依赖</h2><p>以前一直听说 PostgreSQL 很强大，而 Gitlab 也是官方推荐使用 PostgreSQL，再加上 Gitlab 有官方教程教我们如何把 MySQL 迁移到 PostgreSQL，于是我就萌生了迁移数据库的念头。</p>
<p>按照着 <a href="https://gitlab.com/gitlab-org/gitlab-ce/blob/master/doc/update/mysql_to_postgresql.md" target="_blank" rel="external">Migrating GitLab from MySQL to Postgres</a> 这篇文章，我很轻易就把 MySQL 中的数据迁移到 PostgreSQL 中了。<br>而且每个步骤都没报错，我以为一切正常，谁知道当我执行 <code>service gitlab start</code> 的时候，就报启动失败了。</p>
<p>我一下子就懵了，为什么按照官方教程做还会报错？ 而且报的还是这种抱不到依赖的错误？<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Specified &apos;postgresql&apos; for database adapter, but the gem is not loaded. Add `gem &apos;pg&apos;` to your Gemfile.</div></pre></td></tr></table></figure></p>
<p>我找了很多资料，但基本都是说把 <code>pg</code> 加到 Gemfile ，然后再 <code>bundle install</code> 就好了。<br>但我试过把 <code>vendor/bundle</code> 删掉再重装，还是有这个错误。<br>最后，我找到 <a href="https://gitlab.com/gitlab-org/gitlab-ci/issues/227" target="_blank" rel="external">Gem::LoadError: Specified ‘mysql2’ after update to 7.13
</a> 这个 issue，里面提到在 <code>.bundle/config</code> 里面有一些 bundle 的配置！我发现我里面的配置和这个 issue 提到的配置是一样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">BUNDLE_WITHOUT: development:test:postgres:mysql</div></pre></td></tr></table></figure>
<p>最后，我把上面的 <code>postgres</code> 部分删掉，然后再运行 <code>sudo -u git -H bundle install --without development test mysql --deployment</code> 安装依赖，就能正常启动 gitlab 了。</p>
<p>这时候，我才体会到，不熟悉 ruby 技术栈去搞 gitlab 真是累啊~</p>
<h2 id="Docker-化时自动修改用户组引起其他问题"><a href="#Docker-化时自动修改用户组引起其他问题" class="headerlink" title="Docker 化时自动修改用户组引起其他问题"></a>Docker 化时自动修改用户组引起其他问题</h2><p><strong>严格来说这不是升级 Gitlab 升级过程中遇到的坑，这只是我在尝试把 gitlab docker 化时遇到的问题。</strong></p>
<p>有了上面的经历，我暗下决心，要把 Gitlab Docker 化，这样我就不用操心 Gitlab 相关的问题了，我只要启动下载镜像，运行容器就好了，其他 Gitlab 相关的事情就交回给官方处理好了。</p>
<p>于是，我找到了 <a href="https://github.com/sameersbn/docker-gitlab" target="_blank" rel="external">docker-gitlab</a>，我慢慢去尝试把 Gitlab 扔到 docker 里面运行。</p>
<p>最开始的时候，我直接用 docker-compose 来运行 docker-gitlab，我试着先用 MySQL ，于是我把 <code>docker-compose.yaml</code> 中的 PostgreSQL 部分的东西全部改成 MySQL，然后直接用 <code>docker-compose up</code> 来运行 gitlab 。</p>
<p>虽然运行过程中没看出什么问题，但我后来发现 MySQL 中的用户和用户组都被修改成 <code>messagebus:fuse</code> 了！这样直接导致了我本地的 MySQL 不能正常使用了。</p>
<p>经过调查，我发现是 docker 的 <code>-v</code> 指定已存在目录的时候，会修改文件目录的用户和用户组，最后把它改回 <code>mysql:adm</code> 才恢复正常~</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://stackoverflow.com/questions/22909060/mysql-job-failed-to-start" target="_blank" rel="external">http://stackoverflow.com/questions/22909060/mysql-job-failed-to-start</a><br><a href="https://gitlab.com/gitlab-org/gitlab-ci/issues/227" target="_blank" rel="external">https://gitlab.com/gitlab-org/gitlab-ci/issues/227</a><br><a href="https://github.com/sameersbn/docker-gitlab" target="_blank" rel="external">https://github.com/sameersbn/docker-gitlab</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;最近帮公司的 Gitlab 从 7.14 升级到 8.7.6，升级的主要动机是整合 Gitlab CI，提升持续集成的效率。鉴于之前也是我把
    
    </summary>
    
    
      <category term="gitlab" scheme="http://scarletsky.github.io/tags/gitlab/"/>
    
  </entry>
  
  <entry>
    <title>「译」 MapReduce in MongoDB</title>
    <link href="http://scarletsky.github.io/2016/06/12/mapreduce-in-mongodb/"/>
    <id>http://scarletsky.github.io/2016/06/12/mapreduce-in-mongodb/</id>
    <published>2016-06-12T02:04:53.000Z</published>
    <updated>2016-06-12T06:57:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>在这篇文章里面，我们会演示如何在 MongoDB 中使用 MapReduce 操作。<br>我们会用 <code>dummy-json</code> 这个包来生成一些虚假的数据，然后用 <code>Mongojs</code></p>
<p>如果想要快速看到结果，可以到 <a href="http://code.runnable.com/U1fmE30iHWMIGY_r/mapreduce-in-mongodb-for-node-js" target="_blank" rel="external">这里</a> 里看看。</p>
<h2 id="什么是-MongoDB"><a href="#什么是-MongoDB" class="headerlink" title="什么是 MongoDB ?"></a>什么是 MongoDB ?</h2><p>MongoDB 是一个 NoSQL 数据库，不像 MySQL 、MSSQL 和 Oracle DB 那样，MongoDB 使用集合(collections) 来代替表(tables)。同时，它用集合中的文档(documents)来代替表中的行(rows)。还有最好的一点是，所有文档都保存成 JSON 格式！你可以到<a href="http://try.mongodb.org/" target="_blank" rel="external">这里</a>学更多关于 MongoDB 的知识。</p>
<p>你可以从 <a href="http://www.mongodb.org/downloads" target="_blank" rel="external">这里</a> 下载安装 MongoDB。</p>
<p>如果以前没用过 MongoDB，那么你可以记住下面这些命令:</p>
<table>
<thead>
<tr>
<th>Command</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>mongod</code></td>
<td>启动 MongoDB 服务</td>
</tr>
<tr>
<td><code>mongo</code></td>
<td>进入 MongoDB Shell</td>
</tr>
<tr>
<td><code>show dbs</code></td>
<td>显示所有数据库列表</td>
</tr>
<tr>
<td><code>use &lt;db name&gt;</code></td>
<td>进入指定的数据库</td>
</tr>
<tr>
<td><code>show collections</code></td>
<td>进入数据库之后，显示该数据库中所有的集合</td>
</tr>
<tr>
<td><code>db.collectionName.find()</code></td>
<td>显示该集合中所有文档</td>
</tr>
<tr>
<td><code>db.collectionName.findOne()</code></td>
<td>显示该集合中第一个文档</td>
</tr>
<tr>
<td><code>db.collectionName.find().pretty()</code></td>
<td>显示漂亮的 JSON 格式</td>
</tr>
<tr>
<td><code>db.collectionName.insert({key: value})</code></td>
<td>插入一条新的记录</td>
</tr>
<tr>
<td><code>db.collectionName.update({ condition: value}, {$set: {key: value}}, {upsert: true})</code></td>
<td>会更新指定的文档，设置指定的值。如果 <code>upsert</code> 为 <code>true</code>，当没有找到匹配的文档时，会创建一条新的记录</td>
</tr>
<tr>
<td><code>db.collectionName.remove({})</code></td>
<td>移除集合中的所有文档</td>
</tr>
<tr>
<td><code>db.collectionName.remove({key: value})</code></td>
<td>移除集合中匹配到的文档</td>
</tr>
</tbody>
</table>
<h2 id="什么是-MapReduce"><a href="#什么是-MapReduce" class="headerlink" title="什么是 MapReduce ?"></a>什么是 MapReduce ?</h2><p>弄清楚 MapReduce 是如何运作的是非常重要的，如果对 MapReduce 过程不了解的话，你在运行 MapReduce 时很可能得不到你想要的结果。</p>
<p>从 mongodb.org 上的解析：</p>
<blockquote>
<p>Map-reduce 是一种数据处理范例，用于将大量的数据变成有用的聚合结果。 对于 map-reduce 操作，MongoDB 提供了 mapReduce 的数据库命令。</p>
</blockquote>
<p>在这非常简单的术语里面，mapReduce 命令接受两个基本的输入：mapper 函数和 reducer 函数。</p>
<p>Mapper 是一个匹配数据的过程，它会在集合中查询我们想要处理的字段，然后根据我们指定的 key 去分组，再把这些 key-value 对交给 reducer 函数，由它来处理这些匹配到的数据。</p>
<p>我们来看看下面这些数据：</p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">[</div><div class="line">  &#123; name: foo, price: 9 &#125;,</div><div class="line">  &#123; name: foo, price: 12 &#125;,</div><div class="line">  &#123; name: bar, price: 8 &#125;,</div><div class="line">  &#123; name: baz, price: 3 &#125;,</div><div class="line">  &#123; name: baz, price: 5 &#125;</div><div class="line">]</div></pre></td></tr></table></figure>
<p>我们想要计算出相同名字下的所需要的价钱。我们将会用这个数据通过 Mapper 和 Reducer 去获得结果。</p>
<p>当我们让 Mapper 去处理上面的数据时，会生成如下的结果：</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>foo</td>
<td>[9,12]</td>
</tr>
<tr>
<td>bar</td>
<td>[8]</td>
</tr>
<tr>
<td>baz</td>
<td>[3,5]</td>
</tr>
</tbody>
</table>
<p>看到了吗？它用相同的 key 去分组数据。在我们的例子中，是用 name 分组。这些结果会发送到 Reducer 中。</p>
<p>现在，在 reducer 中，我们会得到上面表格中的第一行数据，然后迭代这些数据然后把它们加起来，这就是第一行数据的总和。然后 reducer 会对第二行数据做同样的事情，直到所有行被处理完。</p>
<p>最终的输出结果如下：</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Total</th>
</tr>
</thead>
<tbody>
<tr>
<td>foo</td>
<td>21</td>
</tr>
<tr>
<td>bar</td>
<td>8</td>
</tr>
<tr>
<td>baz</td>
<td>8</td>
</tr>
</tbody>
</table>
<p>现在你明白为什么 Mapper 会叫 Mapper 了吧 ! (因为它会创建一份数据的映射)<br>也明白了为什么 Reducer 会叫 Reducer 了吧 ! (因为它会把 Mapper 生成的数据归纳成一个简单的形式)</p>
<p>如果你运行一些例子，你就会知道它是怎么工作的拉。你也可以从<a href="https://docs.mongodb.com/manual/core/map-reduce/" target="_blank" rel="external">官方文档</a> 中了解更多细节。</p>
<h2 id="创建一个项目"><a href="#创建一个项目" class="headerlink" title="创建一个项目"></a>创建一个项目</h2><p>正如上文所说，我们可以在 mongo shell 中直接查询和看到输出结果。但是，为了让教程更加丰富，我们会构建一个 Nodejs 项目，在里面运行我们之前的任务。</p>
<h3 id="Mongojs"><a href="#Mongojs" class="headerlink" title="Mongojs"></a>Mongojs</h3><p>我们会用 <code>mongojs</code> 去实现我们的 MapReduce。你可以用同样的代码跑在 mongo shell 里面，会看到同样的结果。</p>
<h3 id="Dummy-json"><a href="#Dummy-json" class="headerlink" title="Dummy-json"></a>Dummy-json</h3><p>我们会用 <code>dummy-json</code> 去创建一些虚假的数据。你可以在 <a href="https://github.com/webroo/dummy-json" target="_blank" rel="external">这里</a> 找到更多的信息。然后我们会在这些虚假数据上面运行 MapReduce 命令，生成一些有意义的结果。</p>
<p>我们开始吧！</p>
<p>首先，你要安装 Nodejs，你可以看看 <a href="http://thejackalofjavascript.com/hello-node/" target="_blank" rel="external">这里</a>。然后你要创建一个叫 mongoDBMapReduce 的目录。我们将会创建 <code>package.json</code> 文件来保存项目的详细信息。</p>
<p>运行 <code>npm init</code> 然后填入你喜欢的东西，创建完 <code>package.json</code> 后，我们要添加项目的依赖。<br>运行 <code>npm i mongojs dummy-json --save-dev</code> ，然后等几分钟之后，我们项目的依赖就安装好了。</p>
<h2 id="生成虚假数据"><a href="#生成虚假数据" class="headerlink" title="生成虚假数据"></a>生成虚假数据</h2><p>下一步，我们要用 <code>dummy-json</code> 模块来生成虚假数据。<br>在项目的根目录创建一个名叫 <code>dataGen.js</code> 的文件，我们会把数据生成的逻辑保存到一个独立的文件里面。如果以后需要添加更多的数据，你可以运行这个文件。</p>
<p>把下面的内容复制到 <code>dataGen.js</code> 里面：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> mongojs = <span class="built_in">require</span>(<span class="string">'mongojs'</span>);</div><div class="line"><span class="keyword">var</span> db = mongojs(<span class="string">'mapReduceDB'</span>, [<span class="string">'sourceData'</span>]);</div><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"><span class="keyword">var</span> dummyjson = <span class="built_in">require</span>(<span class="string">'dummy-json'</span>);</div><div class="line"> </div><div class="line"><span class="keyword">var</span> helpers = &#123;</div><div class="line">  <span class="attr">gender</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">""</span>+ <span class="built_in">Math</span>.random() &gt; <span class="number">0.5</span> ? <span class="string">'male'</span> : <span class="string">'female'</span>;</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">dob</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> start = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">1900</span>, <span class="number">0</span>, <span class="number">1</span>),</div><div class="line">        end = <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(start.getTime() + <span class="built_in">Math</span>.random() * (end.getTime() - start.getTime()));</div><div class="line">    &#125;,</div><div class="line">  <span class="attr">hobbies</span> : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> hobbysList = []; </div><div class="line">    hobbysList[<span class="number">0</span>] = [];</div><div class="line">    hobbysList[<span class="number">0</span>][<span class="number">0</span>] = [<span class="string">"Acrobatics"</span>, <span class="string">"Meditation"</span>, <span class="string">"Music"</span>];</div><div class="line">    hobbysList[<span class="number">0</span>][<span class="number">1</span>] = [<span class="string">"Acrobatics"</span>, <span class="string">"Photography"</span>, <span class="string">"Papier-Mache"</span>];</div><div class="line">    hobbysList[<span class="number">0</span>][<span class="number">2</span>] = [ <span class="string">"Papier-Mache"</span>];</div><div class="line">    <span class="keyword">return</span> hobbysList[<span class="number">0</span>][<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * hobbysList[<span class="number">0</span>].length)];</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="built_in">console</span>.log(<span class="string">"Begin Parsing &gt;&gt;"</span>);</div><div class="line"> </div><div class="line"><span class="keyword">var</span> template = fs.readFileSync(<span class="string">'schema.hbs'</span>, &#123;<span class="attr">encoding</span>: <span class="string">'utf8'</span>&#125;);</div><div class="line"><span class="keyword">var</span> result = dummyjson.parse(template, &#123;<span class="attr">helpers</span>: helpers&#125;);</div><div class="line"> </div><div class="line"><span class="built_in">console</span>.log(<span class="string">"Begin Database Insert &gt;&gt;"</span>);</div><div class="line"> </div><div class="line">db.sourceData.remove(<span class="function"><span class="keyword">function</span> (<span class="params">argument</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"DB Cleanup Completd"</span>);</div><div class="line">&#125;);</div><div class="line"> </div><div class="line">db.sourceData.insert(<span class="built_in">JSON</span>.parse(result), <span class="function"><span class="keyword">function</span> (<span class="params">err, docs</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"DB Insert Completed"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><strong>第1-4行</strong>，我们引入了所有依赖。<br><strong>第2行</strong>，我们创建了一个叫 <code>mapReduceDB</code> 的数据库。在数据库里面，创建了一个叫 <code>sourceData</code> 的集合。</p>
<p><strong>第6-23行</strong>，是 Handlebar 的 helper。你可以到 <code>dummy-json</code> 中了解更多信息。</p>
<p><strong>第27-28行</strong>，我们读取了 <code>schema.hbs</code> 文件 (我们接着会创建这个文件)，然后把它解析成 JSON。</p>
<p><strong>第32行</strong>，在插入新数据之前，我们要先把旧数据清除掉。如果你想保留旧数据，把这部分注释掉就好了。</p>
<p><strong>第36行</strong>，把生成的数据插入数据库。</p>
<p>接着，我们要在项目根目录创建一个叫 <code>schema.hbs</code> 的文件。这里面会包括 JSON 文档的结构。把下面的内容复制到文件里面：</p>
<figure class="highlight hbs"><table><tr><td class="code"><pre><div class="line"><span class="xml">[</span></div><div class="line">    <span class="template-tag">&#123;&#123;#<span class="name">repeat</span> 9999&#125;&#125;</span><span class="xml"></span></div><div class="line">    &#123;</div><div class="line">      "id": <span class="template-variable">&#123;&#123;index&#125;&#125;</span><span class="xml">,</span></div><div class="line">      "name": "<span class="template-variable">&#123;&#123;firstName&#125;&#125;</span><span class="xml"> </span><span class="template-variable">&#123;&#123;lastName&#125;&#125;</span><span class="xml">",</span></div><div class="line">      "email": "<span class="template-variable">&#123;&#123;email&#125;&#125;</span><span class="xml">",</span></div><div class="line">      "work": "<span class="template-variable">&#123;&#123;company&#125;&#125;</span><span class="xml">",</span></div><div class="line">      "dob" : "<span class="template-variable">&#123;&#123;dob&#125;&#125;</span><span class="xml">",</span></div><div class="line">      "age": <span class="template-variable">&#123;&#123;number 1 99&#125;&#125;</span><span class="xml">,</span></div><div class="line">      "gender" : "<span class="template-variable">&#123;&#123;gender&#125;&#125;</span><span class="xml">",</span></div><div class="line">      "salary" : <span class="template-variable">&#123;&#123;number 999 99999&#125;&#125;</span><span class="xml">,</span></div><div class="line">      "hobbies" : "<span class="template-variable">&#123;&#123;hobbies&#125;&#125;</span><span class="xml">"</span></div><div class="line">    &#125;</div><div class="line">    <span class="template-tag">&#123;&#123;/<span class="name">repeat</span>&#125;&#125;</span><span class="xml"></span></div><div class="line">]</div></pre></td></tr></table></figure>
<p>注意 <strong>第2行</strong>，我们会生成 9999 个文档。</p>
<p>打开一个新的终端，运行 <code>mongod</code>，启动 MongoDB 服务。然后回到原来的终端，运行 <code>node dataGen.js</code>。</p>
<p>如果一切正常，会显示如下结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ node dataGen.js</div><div class="line">Begin Parsing &gt;&gt;</div><div class="line">Begin Database Insert &gt;&gt;</div><div class="line">DB Cleanup Completed</div><div class="line">DB Insert Completed</div></pre></td></tr></table></figure>
<p>然后按 ctrl + c 杀掉 Node 程序。要验证是否插入成功，我们可以打开一个新的终端，运行 <code>mongo</code> 命令进入 mongo shell。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; use mapReduceDB</div><div class="line">&gt; db.sourceData.findOne()</div><div class="line">&#123;</div><div class="line">    &quot;id&quot;: 0,</div><div class="line">    &quot;name&quot;: &quot;Leanne Flinn&quot;,</div><div class="line">    &quot;email&quot;: &quot;leanne.flinn@unilogic.com&quot;,</div><div class="line">    &quot;work&quot;: &quot;Unilogic&quot;,</div><div class="line">    &quot;dob&quot;: &quot;Sun Mar 14 1909 12:45:53 GTM+0530 (LST)&quot;,</div><div class="line">    &quot;age&quot;: 27,</div><div class="line">    &quot;gender&quot;: &quot;male&quot;,</div><div class="line">    &quot;salary&quot;: 16660,</div><div class="line">    &quot;hobbies&quot;: &quot;Acrobatics,Photography,Papier-Mache&quot;,</div><div class="line">    &quot;_id&quot;: Object(&quot;57579f702fa6c7651e504fe2&quot;)</div><div class="line">&#125;</div><div class="line">&gt; db.sourceData.count()</div><div class="line">9999</div></pre></td></tr></table></figure>
<h2 id="有意义的数据"><a href="#有意义的数据" class="headerlink" title="有意义的数据"></a>有意义的数据</h2><p>现在我们有 9999 个虚假用户的数据，让我们试着把数据变得有意义</p>
<h3 id="例子1：计算男女数量"><a href="#例子1：计算男女数量" class="headerlink" title="例子1：计算男女数量"></a>例子1：计算男女数量</h3><p>首先，在项目根目录创建一个 <code>example1.js</code> 的文件，我们要进行 MapReduce 操作，去计算男女的数量。</p>
<h4 id="Mapper-的逻辑"><a href="#Mapper-的逻辑" class="headerlink" title="Mapper 的逻辑"></a>Mapper 的逻辑</h4><p>我们只需要让 Mapper 以性别作为 key，把值作为 1。因为一个用户不是男就是女。所以，Mapper 的输出会是下面这样：</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>Male</td>
<td>[1,1,1…]</td>
</tr>
<tr>
<td>Female</td>
<td>[1,1,1,1,1…]</td>
</tr>
</tbody>
</table>
<h4 id="Reducer-的逻辑"><a href="#Reducer-的逻辑" class="headerlink" title="Reducer 的逻辑"></a>Reducer 的逻辑</h4><p>在 Reducer 中，我们会获得上面两行数据，我们要做的是把每一行中的值求和，表示该性别的总数。最终的输出结果如下：</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>Male</td>
<td>5031</td>
</tr>
<tr>
<td>Female</td>
<td>4968</td>
</tr>
</tbody>
</table>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>好了，现在我们可以写代码去实现了。在 <code>example1.js</code> 中，我们要先引入所需要的依赖。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> mongojs = <span class="built_in">require</span>(<span class="string">'mongojs'</span>);</div><div class="line"><span class="keyword">var</span> db = mongojs(<span class="string">'mapReduceDB'</span>, [<span class="string">'sourceData'</span>, <span class="string">'example1_results'</span>]);</div></pre></td></tr></table></figure>
<p>注意 <strong>第2行</strong>，第一个参数是数据库的名字，第二个参数表示集合的数组。<code>example1_results</code> 集合用来保存结果。</p>
<p>接下来，我们加上 mapper 和 reducer 函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> mapper = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    emit(<span class="keyword">this</span>.gender, <span class="number">1</span>);</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="keyword">var</span> reducer = <span class="function"><span class="keyword">function</span>(<span class="params">gender, count</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.sum(count);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在<strong>第2行</strong>中， <code>this</code> 表示当前的文档，因此 <code>this.gender</code> 会作为 mapper 的 key，它的值要么是 <code>male</code>，要么是 <code>female</code>。而 <code>emit()</code> 将会把数据发送到一个临时保存数据的地方，作为 mapper 的结果。</p>
<p>在<strong>第5行</strong>中，我们简单地把每个性别的所有值加起来。</p>
<p>最后，加上执行逻辑：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">db.sourceData.mapReduce(</div><div class="line">    mapper,</div><div class="line">    reducer,</div><div class="line">    &#123;</div><div class="line">        <span class="attr">out</span> : <span class="string">"example1_results"</span></div><div class="line">    &#125;</div><div class="line"> );</div><div class="line"> </div><div class="line"> db.example1_results.find(<span class="function"><span class="keyword">function</span> (<span class="params">err, docs</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span>(err) <span class="built_in">console</span>.log(err);</div><div class="line">    <span class="built_in">console</span>.log(docs);</div><div class="line"> &#125;);</div></pre></td></tr></table></figure>
<p>在<strong>第5行</strong>中，我们设置了输出的集合名。<br>在<strong>第9行</strong>中，我们会从 <code>example1_results</code> 集合取得结果并显示它。</p>
<p>我们可以在终端运行试试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ node example1.js</div><div class="line">[ &#123; _id: &apos;female&apos;, value: 4968 &#125;, &#123; _id: &apos;male&apos;: value: 5031 &#125; ]</div></pre></td></tr></table></figure>
<p>我的数量可能和你的不一样，但男女总数应该是 9999 !</p>
<h4 id="Mongo-Shell-代码"><a href="#Mongo-Shell-代码" class="headerlink" title="Mongo Shell 代码"></a>Mongo Shell 代码</h4><p>如果你想在 mongo shell 中运行上面的例子，你可以粘贴下面这些代码到终端里面：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">mapper = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    emit(<span class="keyword">this</span>.gender, <span class="number">1</span>);</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">reducer = <span class="function"><span class="keyword">function</span>(<span class="params">gender, count</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.sum(count);</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">db.sourceData.mapReduce(</div><div class="line">    mapper,</div><div class="line">    reducer,</div><div class="line">    &#123;</div><div class="line">        <span class="attr">out</span> : <span class="string">"example1_results"</span></div><div class="line">    &#125;</div><div class="line"> );</div><div class="line"> </div><div class="line"> db.example1_results.find()</div></pre></td></tr></table></figure>
<p>然后你就会看到一样的结果，很简单吧！</p>
<h3 id="例子2：获取每个性别中最老和最年轻的人"><a href="#例子2：获取每个性别中最老和最年轻的人" class="headerlink" title="例子2：获取每个性别中最老和最年轻的人"></a>例子2：获取每个性别中最老和最年轻的人</h3><p>在项目根目录创建一个 <code>example2.js</code> 的文件。在这里，我们要把所有用户根据性别分组，然后分别找每个性别中最老和最年轻的用户。这个例子比前面的稍微复杂一点。</p>
<h4 id="Mapper-的逻辑-1"><a href="#Mapper-的逻辑-1" class="headerlink" title="Mapper 的逻辑"></a>Mapper 的逻辑</h4><p>在 mapper 中，我们要以性别作为 key，然后以 object 作为 value。这个 object 要包含用户的年龄和名字。年龄是用来做计算用的，而名字只是用来显示给人看的。</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>Male</td>
<td>[{age: 9, name: ‘John’}, …]</td>
</tr>
<tr>
<td>Female</td>
<td>[{age: 19, name: ‘Rita’}, …]</td>
</tr>
</tbody>
</table>
<h4 id="Reducer-的逻辑-1"><a href="#Reducer-的逻辑-1" class="headerlink" title="Reducer 的逻辑"></a>Reducer 的逻辑</h4><p>我们的 reducer 会比前一个例子要复杂一点。我们要检查所有和性别相关的年龄，找到年龄最大和最小的用户。最终的输出结果是这样的：</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>Male</td>
<td>{min: {name: ‘harry’, age: 1}, max: {name: ‘Alex’, age: 99} }</td>
</tr>
<tr>
<td>Female</td>
<td>{min: {name: ‘Loli’, age: 10}, max: {name: ‘Mary’, age: 98} }</td>
</tr>
</tbody>
</table>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><p>现在打开 <code>example2.js</code>，粘贴下面的内容进去：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> mongojs = <span class="built_in">require</span>(<span class="string">'mongojs'</span>);</div><div class="line"><span class="keyword">var</span> db = mongojs(<span class="string">'mapReduceDB'</span>, [<span class="string">'sourceData'</span>, <span class="string">'example2_results'</span>]);</div><div class="line"> </div><div class="line"> </div><div class="line"><span class="keyword">var</span> mapper = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> x = &#123;<span class="attr">age</span> : <span class="keyword">this</span>.age, <span class="attr">name</span> : <span class="keyword">this</span>.name&#125;;</div><div class="line">    emit(<span class="keyword">this</span>.gender, &#123;<span class="attr">min</span> : x , <span class="attr">max</span> : x&#125;);</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"> </div><div class="line"><span class="keyword">var</span> reducer = <span class="function"><span class="keyword">function</span>(<span class="params">key, values</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> res = values[<span class="number">0</span>];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; values.length; i++) &#123;</div><div class="line">        <span class="keyword">if</span>(values[i].min.age &lt; res.min.age)</div><div class="line">            res.min = &#123;<span class="attr">name</span> : values[i].min.name, <span class="attr">age</span> : values[i].min.age&#125;;</div><div class="line">        <span class="keyword">if</span> (values[i].max.age &gt; res.max.age) </div><div class="line">           res.max = &#123;<span class="attr">name</span> : values[i].max.name, <span class="attr">age</span> : values[i].max.age&#125;;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"> </div><div class="line">db.sourceData.mapReduce(</div><div class="line">    mapper,</div><div class="line">    reducer,</div><div class="line">    &#123;</div><div class="line">        <span class="attr">out</span> : <span class="string">"example2_results"</span></div><div class="line">    &#125;</div><div class="line"> );</div><div class="line"> </div><div class="line"> db.example2_results.find(<span class="function"><span class="keyword">function</span> (<span class="params">err, docs</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span>(err) <span class="built_in">console</span>.log(err);</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(docs));</div><div class="line"> &#125;);</div></pre></td></tr></table></figure>
<p>在<strong>第6行</strong>，我们构建了一个 object，把它作为 value 发送。<br>在<strong>第13-18行</strong>，我们迭代了所有 object，检查当前的 object 的年龄是否大于或小于前一个 object 的年龄，如果是，就会更新 <code>res.max</code> 或者 <code>res.min</code>。<br>在第<strong>第27行</strong>，我们把结果输出到 <code>example2_results</code> 中。</p>
<p>我们可以运行一下这个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ node example2.js</div><div class="line">[ &#123; _id: &apos;female&apos;, value: &#123; min: [Object], max: [Object] &#125; &#125;,</div><div class="line">  &#123; _id: &apos;male&apos;, value: &#123; min: [Object], max: [Object] &#125; &#125; ]</div></pre></td></tr></table></figure>
<h3 id="例子3：计算每种兴趣爱好的人数"><a href="#例子3：计算每种兴趣爱好的人数" class="headerlink" title="例子3：计算每种兴趣爱好的人数"></a>例子3：计算每种兴趣爱好的人数</h3><p>在我们最后的例子中，我们会看看有多少用户有相同的兴趣爱好。我们在项目根目录创建一个叫 <code>example3.js</code> 的文件。用户数据长这样子：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"id"</span>: <span class="number">0</span>,</div><div class="line">    <span class="attr">"name"</span>: <span class="string">"Leanne Flinn"</span>,</div><div class="line">    <span class="attr">"email"</span>: <span class="string">"leanne.flinn@unilogic.com"</span>,</div><div class="line">    <span class="attr">"work"</span>: <span class="string">"Unilogic"</span>,</div><div class="line">    <span class="attr">"dob"</span>: <span class="string">"Sun Mar 14 1909 12:45:53 GTM+0530 (LST)"</span>,</div><div class="line">    <span class="attr">"age"</span>: <span class="number">27</span>,</div><div class="line">    <span class="attr">"gender"</span>: <span class="string">"male"</span>,</div><div class="line">    <span class="attr">"salary"</span>: <span class="number">16660</span>,</div><div class="line">    <span class="attr">"hobbies"</span>: <span class="string">"Acrobatics,Photography,Papier-Mache"</span>,</div><div class="line">    <span class="attr">"_id"</span>: Object(<span class="string">"57579f702fa6c7651e504fe2"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如你所见，每个用户的兴趣爱好列表都用逗号分隔。我们会找出有多少用户有表演杂技的爱好等等。</p>
<h4 id="Mapper-的逻辑-2"><a href="#Mapper-的逻辑-2" class="headerlink" title="Mapper 的逻辑"></a>Mapper 的逻辑</h4><p>在这个场景下，我们的 mapper 会复杂一点。我们要为每个用户的兴趣爱好发送一个新的 key-value 对。这样，每个用户的每个兴趣爱好都会触发一次计算。最终我们会得到如下的结果：</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>Acrobatics</td>
<td>[1,1,1,1,1,1,….]</td>
</tr>
<tr>
<td>Meditation</td>
<td>[1,1,1,1,1,1,….]</td>
</tr>
<tr>
<td>Music</td>
<td>[1,1,1,1,1,1,….]</td>
</tr>
<tr>
<td>Photography</td>
<td>[1,1,1,1,1,1,….]</td>
</tr>
<tr>
<td>Papier-Mache</td>
<td>[1,1,1,1,1,1,….]</td>
</tr>
</tbody>
</table>
<h4 id="Reducer-的逻辑-2"><a href="#Reducer-的逻辑-2" class="headerlink" title="Reducer 的逻辑"></a>Reducer 的逻辑</h4><p>在这里，我们只要简单地为每种兴趣爱好求和就好了。最终我们会得到下面的结果：</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>Acrobatics</td>
<td>6641</td>
</tr>
<tr>
<td>Meditation</td>
<td>3338</td>
</tr>
<tr>
<td>Music</td>
<td>3338</td>
</tr>
<tr>
<td>Photography</td>
<td>3303</td>
</tr>
<tr>
<td>Papier-Mache</td>
<td>6661</td>
</tr>
</tbody>
</table>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> mongojs = <span class="built_in">require</span>(<span class="string">'mongojs'</span>);</div><div class="line"><span class="keyword">var</span> db = mongojs(<span class="string">'mapReduceDB'</span>, [<span class="string">'sourceData'</span>, <span class="string">'example3_results'</span>]);</div><div class="line"> </div><div class="line"> </div><div class="line"><span class="keyword">var</span> mapper = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">     <span class="keyword">var</span> hobbys = <span class="keyword">this</span>.hobbies.split(<span class="string">','</span>);</div><div class="line">      <span class="keyword">for</span> (i <span class="keyword">in</span> hobbys) &#123;</div><div class="line">        emit(hobbys[i], <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="keyword">var</span> reducer = <span class="function"><span class="keyword">function</span> (<span class="params">key, values</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> count = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (index <span class="keyword">in</span> values) &#123;</div><div class="line">        count += values[index];</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="keyword">return</span> count;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"> </div><div class="line">db.sourceData.mapReduce(</div><div class="line">    mapper,</div><div class="line">    reducer,</div><div class="line">    &#123;</div><div class="line">        <span class="attr">out</span> : <span class="string">"example3_results"</span></div><div class="line">    &#125;</div><div class="line"> );</div><div class="line"> </div><div class="line"> db.example3_results.find(<span class="function"><span class="keyword">function</span> (<span class="params">err, docs</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span>(err) <span class="built_in">console</span>.log(err);</div><div class="line">    <span class="built_in">console</span>.log(docs);</div><div class="line"> &#125;);</div></pre></td></tr></table></figure>
<p>注意<strong>第7-9行</strong>，我们迭代了每个兴趣爱好，然后发送了一次记数。<br><strong>第13-18行</strong>可以用 <code>Array.sum(values)</code> 来代替，这样是另外一种做相同事情的方式。最终我们得到的结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ node example3.js</div><div class="line">[ &#123; _id: &apos;Acrobatics&apos;, value: 6641 &#125;,</div><div class="line">  &#123; _id: &apos;Meditation&apos;, value: 3338 &#125;,</div><div class="line">  &#123; _id: &apos;Music&apos;, value: 3338 &#125;,</div><div class="line">  &#123; _id: &apos;Photography&apos;, value: 6661 &#125;,</div><div class="line">  &#123; _id: &apos;Papier-Mache&apos;, value: 3303 &#125; ]</div></pre></td></tr></table></figure>
<p>这就是 MongoDB 中运行 MapReduce 的方法了。但要记住，有时候一个简单的查询就能完成你想要的事情的。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://thejackalofjavascript.com/mapreduce-in-mongodb/" target="_blank" rel="external">MapReduce in MongoDB</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在这篇文章里面，我们会演示如何在 MongoDB 中使用 MapReduce 操作。&lt;br&gt;我们会用 &lt;code&gt;dummy-json&lt;/code&gt; 这个包来生成一些虚假的数据，然后用 &lt;code&gt;Mongojs&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果想要快速看到结果，可以到 &lt;
    
    </summary>
    
    
      <category term="mongodb" scheme="http://scarletsky.github.io/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>编写 Hubot Scripts</title>
    <link href="http://scarletsky.github.io/2016/05/02/write-your-own-hubot-scripts/"/>
    <id>http://scarletsky.github.io/2016/05/02/write-your-own-hubot-scripts/</id>
    <published>2016-05-02T08:05:37.000Z</published>
    <updated>2016-05-10T05:04:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>我们在上一篇中介绍了 Hubot 的简单用法，里面提到我们可以为机器人编写脚本来让它根据不同的「输入」来给出不同的「输出」。<br>本文将会介绍如何编写我们的 Hubot Scritps。</p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>我们的脚本应该放在哪里才能让 hubot 找到并且正常加载呢？在上一篇文章中我们提到过，hubot 在启动时会加载 <code>scripts/</code> 目录中的脚本文件。<br>但它到底是怎么加载的呢？我们可以打开 <code>bin/hubot</code> 文件看一下：</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><div class="line"># ......</div><div class="line">loadScripts = -&gt;</div><div class="line">  # 加载 scripts 中的脚本</div><div class="line">  scriptsPath = Path.resolve &quot;.&quot;, &quot;scripts&quot;</div><div class="line">  robot.load scriptsPath</div><div class="line"></div><div class="line">  # 加载 src/scripts 中的脚本</div><div class="line">  scriptsPath = Path.resolve &quot;.&quot;, &quot;src&quot;, &quot;scripts&quot;</div><div class="line">  robot.load scriptsPath</div><div class="line"></div><div class="line">  # 加载 hubot-scripts.json 中列出的脚本</div><div class="line">  hubotScripts = Path.resolve &quot;.&quot;, &quot;hubot-scripts.json&quot;</div><div class="line">  if Fs.existsSync(hubotScripts)</div><div class="line">    data = Fs.readFileSync(hubotScripts)</div><div class="line">    if data.length &gt; 0</div><div class="line">      try</div><div class="line">        scripts = JSON.parse data</div><div class="line">        scriptsPath = Path.resolve &quot;node_modules&quot;, &quot;hubot-scripts&quot;, &quot;src&quot;, &quot;scripts&quot;</div><div class="line">        robot.loadHubotScripts scriptsPath, scripts</div><div class="line">      catch err</div><div class="line">        console.error &quot;Error parsing JSON data from hubot-scripts.json: #&#123;err&#125;&quot;</div><div class="line">        process.exit(1)</div><div class="line"></div><div class="line">  # 加载 external-scripts.json 中列出的脚本</div><div class="line">  externalScripts = Path.resolve &quot;.&quot;, &quot;external-scripts.json&quot;</div><div class="line">  if Fs.existsSync(externalScripts)</div><div class="line">    Fs.readFile externalScripts, (err, data) -&gt;</div><div class="line">      if data.length &gt; 0</div><div class="line">        try</div><div class="line">          scripts = JSON.parse data</div><div class="line">        catch err</div><div class="line">          console.error &quot;Error parsing JSON data from external-scripts.json: #&#123;err&#125;&quot;</div><div class="line">          process.exit(1)</div><div class="line">        robot.loadExternalScripts scripts</div><div class="line"></div><div class="line">  # 加载由 process.env.HUBOT_SCRIPTS 和 -r 参数指定的脚本</div><div class="line">  for path in Options.scripts</div><div class="line">    if path[0] == &apos;/&apos;</div><div class="line">      scriptsPath = path</div><div class="line">    else</div><div class="line">      scriptsPath = Path.resolve &quot;.&quot;, path</div><div class="line">    robot.load scriptsPath</div><div class="line"># ......</div></pre></td></tr></table></figure>
<p>其实只是先指定脚本路径，然后调用 <code>robot.load</code> 和 <code>robot.loadHubotScripts</code> 而已拉！<br>而这两个方法简单来说是长这样子的：</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><div class="line"><span class="comment"># ......</span></div><div class="line">script = <span class="built_in">require</span>(path)</div><div class="line"></div><div class="line"><span class="keyword">if</span> <span class="keyword">typeof</span> script <span class="keyword">is</span> <span class="string">'function'</span></div><div class="line">  script @</div><div class="line"><span class="keyword">else</span></div><div class="line">  @logger.warning <span class="string">"Expected <span class="subst">#&#123;full&#125;</span> to assign a function to module.exports, got <span class="subst">#&#123;<span class="keyword">typeof</span> script&#125;</span>"</span></div><div class="line"><span class="comment"># ......</span></div></pre></td></tr></table></figure>
<p>它们只是获取脚本路径，然后去 <code>require</code> 脚本，最后把 <code>this</code>(即 robot 对象) 作为参数传给 script 拉！<br>所以明白为什么我们之前说脚本要写成下面这样子了吧！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// coffee</div><div class="line">module.exports = (robot) -&gt;</div><div class="line"></div><div class="line">// js</div><div class="line">module.exports = function(robot) &#123;&#125;</div></pre></td></tr></table></figure>
<p>知道了最基本的脚本写法之后，我们就可以愉快的编写属于我们的 hubot script 拉！</p>
<h2 id="接受消息"><a href="#接受消息" class="headerlink" title="接受消息"></a>接受消息</h2><p>作为一个聊天机器人，hubot 最基本的功能是要监听特定的「输入」。<br>Hubot 给我们提供了三个不同层次的方法来监听输入：<code>robot.hear</code>、<code>robot.respond</code> 和 <code>robot.listen</code>。</p>
<h3 id="robot-hear"><a href="#robot-hear" class="headerlink" title="robot.hear"></a>robot.hear</h3><p>监听任何匹配的「输入」。<br>即在聊天过程中，只要匹配到特定的消息，就会触发回调函数。</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">(robot)</span> -&gt;</span></div><div class="line"></div><div class="line">  <span class="comment"># 匹配任何带有 hello 的消息，如</span></div><div class="line">  <span class="comment"># hello</span></div><div class="line">  <span class="comment"># hellooooo</span></div><div class="line">  <span class="comment"># haha helloooooo</span></div><div class="line">  robot.hear <span class="regexp">/hello/i</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></div><div class="line">    <span class="comment"># do what you want</span></div></pre></td></tr></table></figure>
<h3 id="robot-respond"><a href="#robot-respond" class="headerlink" title="robot.respond"></a>robot.respond</h3><p>监听对 hubot 说的「输入」。<br>即在聊天过程中，前面带有 hubot/hubot:/@hubot 的消息才会被匹配，然后触发回调函数。</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">(robot)</span> -&gt;</span></div><div class="line"></div><div class="line">  <span class="comment"># 匹配对 hubot 说的 hi，如</span></div><div class="line">  <span class="comment"># hubot hi</span></div><div class="line">  <span class="comment"># @hubot hihihi~</span></div><div class="line">  <span class="comment"># hubot: hihihi!</span></div><div class="line">  robot.respond <span class="regexp">/hi/i</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></div><div class="line">    <span class="comment"># do what you want</span></div></pre></td></tr></table></figure>
<h3 id="robot-listen"><a href="#robot-listen" class="headerlink" title="robot.listen"></a>robot.listen</h3><p>自由度最高的监听器，传入一个函数（Match Function）对消息进行匹配。<br>该函数返回 <code>true</code> 时回调函数会被执行。</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">(robot)</span> -&gt;</span></div><div class="line"></div><div class="line">  <span class="comment"># 根据「消息」对象做处理</span></div><div class="line">  robot.listen(</div><div class="line">    <span class="function"><span class="params">(message)</span> -&gt;</span> message.user.name <span class="keyword">is</span> <span class="string">"Scarlex"</span>,</div><div class="line">    <span class="function"><span class="params">(res)</span> -&gt;</span> <span class="comment"># do what you want</span></div><div class="line">  )</div></pre></td></tr></table></figure>
<h2 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h2><p>聊天机器人除了接收「输入」之外，还需要对消息做出「响应」。<br>有没有留意到上面接收消息中的回调函数都有一个 <code>res</code> 呢？<br>你猜对拉！和 Node.js 中的 <code>res</code> 用来响应 <code>req</code> 一样，这里的 <code>res</code> 也是是用来响应「输入」的。<br>其中比较常用的两个方法是 <code>res.send</code> 和 <code>res.reply</code>。</p>
<h3 id="res-send"><a href="#res-send" class="headerlink" title="res.send"></a>res.send</h3><p>这个方法和 <code>robot.hear</code> 相反，会直接把消息发送到聊天室。</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">(robot)</span> -&gt;</span></div><div class="line">  <span class="comment"># 匹配所有 hi 相关的输入，然后发送 hello 到聊天室</span></div><div class="line">  robot.hear <span class="regexp">/hi/i</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></div><div class="line">    res.send <span class="string">'hello'</span></div></pre></td></tr></table></figure>
<h3 id="res-reply"><a href="#res-reply" class="headerlink" title="res.reply"></a>res.reply</h3><p>这个方法和 <code>robot.respond</code> 相反，谁对 hubot 聊天就会回复谁。</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">(robot)</span> -&gt;</span></div><div class="line">  <span class="comment"># 匹配所有对 hubot 说的 hi，然后回复对 hubot 说话的用户，如</span></div><div class="line">  <span class="comment"># 输入 @hubot hi</span></div><div class="line">  <span class="comment"># 输出 @scarlex hello</span></div><div class="line">  robot.respond <span class="regexp">/hi/i</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></div><div class="line">    res.reply <span class="string">'hello'</span></div></pre></td></tr></table></figure>
<h3 id="res-match"><a href="#res-match" class="headerlink" title="res.match"></a>res.match</h3><p>只有上面两个方法是远远不够的，因为上面两个方法并不能对「输入」做任何处理。<br>不知道童鞋们有没有发现，我们其实是用正则表达式来匹配输入的，而正则表达式刚好可以用来做匹配某些关键字！<br>当匹配到关键字之后，我们从哪里可以提取到这些关键字呢？<br>答案就是 <code>res.match</code> 拉！</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><div class="line">module.exports = (robot) -&gt;</div><div class="line">  # 用 res.match 来获取正则表达式匹配的结果，如</div><div class="line">  # 输入 open the first door</div><div class="line">  # 输出 opening the first door</div><div class="line">  robot.hear /open the (.*) door/i, (res) -&gt;</div><div class="line">    res.send &quot;opening the #&#123;res.match[1]&#125; door&quot;</div></pre></td></tr></table></figure>
<h2 id="发出-http-请求"><a href="#发出-http-请求" class="headerlink" title="发出 http 请求"></a>发出 http 请求</h2><p>只是匹配消息再回复太简单拉！其实我们可以通过 hubot 发出 http 请求来做出更多的事情！<br>Hubot 自带一个 <a href="https://github.com/technoweenie/node-scoped-http-client" target="_blank" rel="external">node-scoped-http-client</a> 来发 http 请求。<br>用法如下：</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><div class="line">robot</div><div class="line">  .http(<span class="string">'https://github.com'</span>)</div><div class="line">  .get() (err, response, body) -&gt;</div><div class="line">    <span class="comment"># do what you want</span></div></pre></td></tr></table></figure>
<p>初看会觉得很奇怪，其实这只是一个高阶函数而已，对应的 javascript 是这样的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">robot</div><div class="line">  .http(<span class="string">'https://github.com'</span>)</div><div class="line">  .get()(<span class="function"><span class="keyword">function</span>(<span class="params">err, response, body</span>) </span>&#123;</div><div class="line">    <span class="comment">// do what you want</span></div><div class="line">  &#125;)</div></pre></td></tr></table></figure>
<p>事实上，由于我们是在 Node.js 环境下运行 hubot 的， 我们可以用任何 http client 库来实现这个需求，如著名的 <a href="https://github.com/request/request" target="_blank" rel="external">request</a> 库。<br>我们要做的只是运行 <code>npm install request --save</code> 再 <code>require</code> 进来就可以了。</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><div class="line">request = <span class="built_in">require</span> <span class="string">'request'</span></div><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">(robot)</span> -&gt;</span></div><div class="line">  robot.hear <span class="regexp">/get github page/i</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></div><div class="line">    request.get <span class="string">'https://github.com'</span>, <span class="function"><span class="params">(err, response, body)</span> -&gt;</span></div><div class="line">      res.send response.statusCode</div></pre></td></tr></table></figure>
<p>我在这里只演示了 GET 请求，其他类型的请求相信也难不倒大家拉！遇到什么问题去翻翻类库的文档就好拉！</p>
<p>需要提醒一点，在发出 http 请求的时候，不要搞错了 hubot 的 <code>res</code> 对象和 request 的 <code>res</code> 对象哦！</p>
<h2 id="响应-http-请求"><a href="#响应-http-请求" class="headerlink" title="响应 http 请求"></a>响应 http 请求</h2><p>Hubot 内置了一个 <a href="https://github.com/expressjs/express" target="_blank" rel="external">express</a> 来响应 http 请求。<br>它会随 hubot 一并启动，默认端口是 8080，我们可以设置环境变量 <code>EXPRESS_PORT</code> 或 <code>PORT</code> 来改变默认的端口。<br>那么我们怎么才能使用它呢？很简单，只要调用 <code>robot.router</code> 就可以拉！</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">(robot)</span> -&gt;</span></div><div class="line">  <span class="comment"># 打开浏览器，然后输入 http://localhost:8080/hubot/haha</span></div><div class="line">  <span class="comment"># 会看见浏览器显示 ok</span></div><div class="line">  robot.router.get <span class="string">'/hubot/haha'</span>, <span class="function"><span class="params">(req, res)</span> -&gt;</span></div><div class="line">    res.send <span class="string">'ok'</span></div></pre></td></tr></table></figure>
<p>尽情发挥你的想象力去写一些有趣的东西吧！</p>
<p>哦，对了，如果想要禁用这个 express，只要在启动的时候加个 <code>-d</code> 或者 <code>--disable-httpd</code> 就好了。<br>或者设置环境变量 <code>HUBOT_HTTPD</code> 为 <code>false</code> 也可以！<br>即下面的方式都可以：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ ./bin/hubot -d</div><div class="line">$ ./bin/hubot --disable-httpd</div><div class="line">$ HUBOT_HTTPD=false ./bin/hubot</div></pre></td></tr></table></figure>
<p>当看到控制台输出下面这种警告的时候，就表示 express 被禁止启动拉！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">WARNING A script has tried registering a HTTP route while the HTTP server is disabled with --disabled-httpd.</div></pre></td></tr></table></figure>
<h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><p>还有一点需要提的是，hubot 自带了一个 EventEmitter，这意味着我们可以通过 <code>robot.emit</code> 和 <code>robot.on</code> 来编写基于事件通讯的代码~</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">(robot)</span> -&gt;</span></div><div class="line"></div><div class="line">  <span class="comment"># 监听输入 event test，然后用 robot.emit 触发 wow 事件</span></div><div class="line">  robot.hear <span class="regexp">/event test/i</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></div><div class="line">    args = &#123; id: <span class="string">'12345'</span> &#125;</div><div class="line">    robot.emit <span class="string">'wow'</span>, args</div><div class="line">    res.send <span class="string">'emit wow event with args: '</span> + JSON.stringify args</div><div class="line"></div><div class="line">  <span class="comment"># 用 robot.on 来监听 wow 事件，回调函数中可以获取事件发送过来的参数</span></div><div class="line">  <span class="comment"># 控制台会输出 &#123; id: '12345' &#125;</span></div><div class="line">  robot.<span class="literal">on</span> <span class="string">'wow'</span>, <span class="function"><span class="params">(args)</span> -&gt;</span></div><div class="line">    robot.logger.info args</div></pre></td></tr></table></figure>
<p>这种基于事件通讯的代码非常适合和 webhook 一起使用哦！<br>想象一下，当我们 push 代码到 master 分支的时候，触发一个 webhook，然后 hubot 就帮我们自动部署新版网站，很棒吧！</p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>任何代码都不是完美的，它们都有可能报错，当出现错误的时候，我们就需要对错误进行处理拉！<br>在 hubot 里，我们可以用 <code>robot.error</code> 来捕获错误！</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">(robot)</span> -&gt;</span></div><div class="line"></div><div class="line">  <span class="comment"># 输入 error test，会触发一个错误</span></div><div class="line">  robot.hear <span class="regexp">/error test/i</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></div><div class="line">    JSON.parse([])</div><div class="line"></div><div class="line">  <span class="comment"># 触发错误之后会捕获到错误，然后打印 Unexpected Error!</span></div><div class="line">  </div><div class="line">  robot.error (err, res) -&gt;</div><div class="line">    robot.logger.error <span class="string">"Unexpected Error!"</span></div><div class="line">    <span class="keyword">if</span> res?</div><div class="line">      res.reply <span class="string">"Unexpected Error!!!"</span></div></pre></td></tr></table></figure>
<h2 id="其他有趣而无用的方法"><a href="#其他有趣而无用的方法" class="headerlink" title="其他有趣而无用的方法"></a>其他有趣而无用的方法</h2><p>最后提一下，hubot 自带一些有趣而无用的方法，这些方法很少用，有些需要 adapter 支持才能正常使用。</p>
<h3 id="robot-topic"><a href="#robot-topic" class="headerlink" title="robot.topic"></a>robot.topic</h3><h3 id="robot-enter"><a href="#robot-enter" class="headerlink" title="robot.enter"></a>robot.enter</h3><h3 id="robot-leave"><a href="#robot-leave" class="headerlink" title="robot.leave"></a>robot.leave</h3><h3 id="res-random"><a href="#res-random" class="headerlink" title="res.random"></a>res.random</h3><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://hubot.github.com/docs/scripting/" target="_blank" rel="external">https://hubot.github.com/docs/scripting/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;我们在上一篇中介绍了 Hubot 的简单用法，里面提到我们可以为机器人编写脚本来让它根据不同的「输入」来给出不同的「输出」。&lt;br&gt;本文将会
    
    </summary>
    
      <category term="hubot" scheme="http://scarletsky.github.io/categories/hubot/"/>
    
    
      <category term="hubot" scheme="http://scarletsky.github.io/tags/hubot/"/>
    
  </entry>
  
  <entry>
    <title>如何实现无限滚动</title>
    <link href="http://scarletsky.github.io/2016/04/20/how-to-implement-infinite-scroll/"/>
    <id>http://scarletsky.github.io/2016/04/20/how-to-implement-infinite-scroll/</id>
    <published>2016-04-20T09:14:21.000Z</published>
    <updated>2016-04-20T09:18:35.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>无限滚动对我们来说已经是很常见的功能了，具体表现为当页面滚动到某个位置时就自动加载数据，本文将探讨无限滚动的实现原理以及优化。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>我们先看看最简单的无限滚动的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchData</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  fetch(path).then(<span class="function"><span class="params">res</span> =&gt;</span> doSomeThing(res.data));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, fetchData);</div></pre></td></tr></table></figure>
<p>上面就是无限滚动最简单的例子啦~<br>其实就是监听 <code>window</code> 对象的 <code>scroll</code> 事件，然后再触发获取数据的函数~</p>
<p>然而，上面的例子中还有很多问题，其中最大的问题就是 <strong>获取数据的函数(以后叫 fetch 函数)没有触发条件</strong>， 我们还需要不断优化，才能在生产环境下使用。</p>
<h2 id="添加触发条件"><a href="#添加触发条件" class="headerlink" title="添加触发条件"></a>添加触发条件</h2><p>我们先想想，一般情况下，fetch 函数的触发条件有哪些呢 ？</p>
<ul>
<li>在 fetch 过程中不能重复触发</li>
<li>没有更多数据的时候不能再触发</li>
<li>屏幕距离容器边缘 xxx 的时候触发</li>
</ul>
<p>前两点很好处理，只要加个 <code>isLoading</code> 和 <code>isEnd</code> 的变量就可以了。<br>添加这两个变量之后，我们的代码就变成下面的样子啦：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> isLoading = <span class="literal">false</span>;</div><div class="line"><span class="keyword">var</span> isEnd = <span class="literal">false</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchData</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> ( !isLoading &amp;&amp; !isEnd ) &#123;</div><div class="line"></div><div class="line">    isLoading = <span class="literal">true</span>;</div><div class="line"></div><div class="line">    fetch(path).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</div><div class="line">      isLoading = <span class="literal">false</span>;</div><div class="line">      res.data.length === <span class="number">0</span> &amp;&amp; isEnd = <span class="literal">true</span>;</div><div class="line">      doSomething(res.data);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, fetchData);</div></pre></td></tr></table></figure>
<p>第三点对不熟悉 DOM 的童鞋来说就有点难度了~</p>
<h2 id="计算屏幕与容器边缘的距离"><a href="#计算屏幕与容器边缘的距离" class="headerlink" title="计算屏幕与容器边缘的距离"></a>计算屏幕与容器边缘的距离</h2><p>我们以计算屏幕底部与容器底部边缘为例:</p>
<p>如果有 api 可以直接得到元素底部与屏幕底部的距离就最好啦，可以省去麻烦，但实际上并没有这样的 api。<br>然而，我们可以通过浏览器提供的两个 api，计算出元素底部与屏幕底部之间的距离。</p>
<p>第一个 api 是 <code>window.innerHeight</code>，它返回的是屏幕（viewport）高度。<br>第二个 api 就是 <code>Element.getBoundingClientRect</code> ，这个方法用来计算元素边缘与屏幕（viewport）之间的距离。<br>需要提醒一下，<code>Element.getBoundingClientRect</code> 会得到这么一个类 Object 对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">ClientRect &#123;</div><div class="line">  <span class="attr">width</span>: <span class="number">760</span>,   <span class="comment">// 元素宽度</span></div><div class="line">  height: <span class="number">2500</span>, <span class="comment">// 元素高度</span></div><div class="line">  top: <span class="number">-1352</span>,   <span class="comment">// 元素上边缘与屏幕上边缘的距离</span></div><div class="line">  bottom: <span class="number">1239</span>, <span class="comment">// 元素下边缘与屏幕上边缘的距离</span></div><div class="line">  left: <span class="number">760</span>,    <span class="comment">// 元素左边缘与屏幕左边缘的距离</span></div><div class="line">  right: <span class="number">860</span>    <span class="comment">// 元素右边缘与屏幕左边缘的距离</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看看下面这图：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">     +------&gt; +--------------------------------------------------------+</div><div class="line">     |        |                     document.body                      |</div><div class="line">     |        |                                                        |</div><div class="line">     |        |                                                        |</div><div class="line">body.getBoundingClientRect().top                                       |</div><div class="line">     |        |                                                        |</div><div class="line">     |        |                                                        |</div><div class="line">     |        +--------------------------------------------------------+</div><div class="line">     |        | browser                                              x |</div><div class="line">     +------&gt; +--------------------------------------------------------+ &lt;--+</div><div class="line">     |        | window                                                 |    |</div><div class="line">     |        |                                                        |    |</div><div class="line">     |        |                                                        |    |</div><div class="line">     |        |                                                        |    |</div><div class="line">     |        |                                                        |    |</div><div class="line">     |        |                                                        |    |</div><div class="line">     |        |                                                        |    |</div><div class="line">window.innerHeight                                                     |    |</div><div class="line">     |        |                                                        |    |</div><div class="line">     |        |                                                        |    |</div><div class="line">     |        |                               body.getBoundingClientRect().bottom</div><div class="line">     |        |                                                        |    |</div><div class="line">     |        |                                                        |    |</div><div class="line">     |        |                                                        |    |</div><div class="line">     |        |                                                        |    |</div><div class="line">     |        |                                                        |    |</div><div class="line">     +------&gt; +--------------------------------------------------------+    |</div><div class="line">              |                                                        |    |</div><div class="line">              |                                                        |    |</div><div class="line">              |                                                        |    |</div><div class="line">              |                                                        |    |</div><div class="line">              |                                                        |    |</div><div class="line">              |                                                        |    |</div><div class="line">              +--------------------------------------------------------+ &lt;--+</div></pre></td></tr></table></figure>
<p>有了这两个 api，我们很容易就可以计算出元素底部边缘与屏幕底部边缘的位置啦~</p>
<p>我们再修改下我们的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> isLoading = <span class="literal">false</span>;</div><div class="line"><span class="keyword">var</span> isEnd = <span class="literal">false</span>;</div><div class="line"><span class="keyword">var</span> triggerDistance = <span class="number">200</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchData</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> distance = container.getBoundingClientRect().bottom - <span class="built_in">window</span>.innerHeight;</div><div class="line">  <span class="keyword">if</span> ( !isLoading &amp;&amp; !isEnd &amp;&amp; distance &lt; triggerDistance ) &#123;</div><div class="line"></div><div class="line">    isLoading = <span class="literal">true</span>;</div><div class="line"></div><div class="line">    fetch(path).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</div><div class="line">      isLoading = <span class="literal">false</span>;</div><div class="line">      res.data.length === <span class="number">0</span> &amp;&amp; isEnd = <span class="literal">true</span>;</div><div class="line">      doSomething(res.data);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, fetchData);</div></pre></td></tr></table></figure>
<p>修改之后，当容器底部与屏幕底部距离小于 200 的时候，才会触发 fetch 函数，这样我们的无限滚动就更加实用啦！</p>
<h2 id="支持-window-以外的元素"><a href="#支持-window-以外的元素" class="headerlink" title="支持 window 以外的元素"></a>支持 window 以外的元素</h2><p>然而，并不是只有 window 才可以滚动，拥有高度的级块元素只要设置了 <code>overflow: scroll</code> 都是可以滚动的。<br>我们需要再修改一下代码来让级块元素也支持无限滚动！</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchData</span>(<span class="params"></span>) </span>&#123; <span class="comment">/* do something */</span> &#125;</div><div class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, fetchData);</div><div class="line"><span class="built_in">document</span>.getElementById(<span class="string">'container'</span>).addEventListener(<span class="string">'scroll'</span>, fetchData);</div></pre></td></tr></table></figure>
<p>很简单吧！只需要为该容器元素添加一个 scroll 的事件监听器就好啦！</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect" target="_blank" rel="external">https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;无限滚动对我们来说已经是很常见的功能了，具体表现为当页面滚动到某个位置时就自动加载数据，本文将探讨无限滚动的实现原理以及优化。&lt;/p&gt;
&lt;h
    
    </summary>
    
      <category term="javascript" scheme="http://scarletsky.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://scarletsky.github.io/tags/javascript/"/>
    
      <category term="infinite scroll" scheme="http://scarletsky.github.io/tags/infinite-scroll/"/>
    
  </entry>
  
  <entry>
    <title>Hubot 的简单用法</title>
    <link href="http://scarletsky.github.io/2016/04/03/hubot-simple-usage/"/>
    <id>http://scarletsky.github.io/2016/04/03/hubot-simple-usage/</id>
    <published>2016-04-02T16:12:49.000Z</published>
    <updated>2016-04-02T16:16:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Hubot 是 Github 的开源聊天机器人，可以用来做一些自动化任务，如部署网站，翻译语言等等。</p>
<p>你可能会说，这些只要写个脚本就可以做到了吧？</p>
<p>确实，但你写完脚本之后还是需要手动运行那些脚本。</p>
<p>你有没想过其实你可以在常用的聊天软件上说 <code>@xxx, 部署新版本的网站</code>，然后机器人就自动登录服务器，然后执行部署脚本，部署成功后告诉你 <code>新版本的网站已经部署成功</code>。</p>
<p>是的，如果你的聊天软件上集成了 Hubot，你就可以轻松地用它来管理一些繁琐的事情啦！</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>官方推荐我们用 yeoman + hubot 生成器来生成我们的聊天机器人，方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ npm install -g yo generator-hubot</div><div class="line">$ mkdir myhubot &amp;&amp; cd myhubot</div><div class="line">$ yo hubot</div></pre></td></tr></table></figure>
<p>回答一些基本的问题后，我们的聊天机器人就生成好啦~</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>我们的聊天机器人的执行文件是 <code>bin/hubot</code>，我们先看看里面写什么：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ cat ./bin/hubot</div><div class="line"></div><div class="line">#!/bin/sh</div><div class="line"></div><div class="line">set -e</div><div class="line"></div><div class="line">npm install</div><div class="line">export PATH=&quot;node_modules/.bin:node_modules/hubot/node_modules/.bin:$PATH&quot;</div><div class="line"></div><div class="line">exec node_modules/.bin/hubot --name &quot;myhubot&quot; &quot;$@&quot;</div></pre></td></tr></table></figure>
<p>这份执行文件只是先执行 <code>npm install</code>，然后设置环境变量，再执行 <code>node_modules/.bin/hubot</code> 而已，没什么神秘的。</p>
<p>我们试试运行一下这份可执行文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ ./bin/hubot</div><div class="line">myhubot&gt;</div></pre></td></tr></table></figure>
<p>我们看到了一个类似 shell 的东东！试试随便输入一些东西：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">myhubot&gt; hello</div><div class="line">myhubot&gt; world</div><div class="line">myhubot&gt; how are you?</div><div class="line">myhubot&gt; can you hear me?</div></pre></td></tr></table></figure>
<p>我们发现无论我们输入什么，我们的机器人都没有反应，是不是坏掉了？<br>其实并不是这样的，它没反应是因为我们没有对「输入」的处理，如果我们输入一些特定的「输入」，它就会有反应啦！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">myhubot&gt; myhubot ping</div><div class="line">myhubot&gt; PONG</div><div class="line"></div><div class="line">myhubot&gt; myhubot pug me</div><div class="line">myhubot&gt; http://28.media.tumblr.com/tumblr_locinzasB91qzj3syo1_500.jpg</div><div class="line"></div><div class="line">myhubot&gt; myhubot help</div><div class="line">myhubot&gt; myhubot adapter - Reply with the adapter</div><div class="line">myhubot animate me &lt;query&gt; - The same thing as `image me`, except adds a few parameters to try to return an animated GIF instead.</div><div class="line">myhubot echo &lt;text&gt; - Reply back with &lt;text&gt;</div><div class="line">myhubot help - Displays all of the help commands that Hubot knows about.</div><div class="line">myhubot help &lt;query&gt; - Displays all help commands that match &lt;query&gt;.</div><div class="line">myhubot image me &lt;query&gt; - The Original. Queries Google Images for &lt;query&gt; and returns a random top result.</div><div class="line">myhubot map me &lt;query&gt; - Returns a map view of the area returned by `query`.</div><div class="line">myhubot mustache me &lt;url|query&gt; - Adds a mustache to the specified URL or query result.</div><div class="line">myhubot ping - Reply with pong</div><div class="line">myhubot pug bomb N - get N pugs</div><div class="line">myhubot pug me - Receive a pug</div><div class="line">myhubot the rules - Make sure hubot still knows the rules.</div><div class="line">myhubot time - Reply with current time</div><div class="line">myhubot translate me &lt;phrase&gt; - Searches for a translation for the &lt;phrase&gt; and then prints that bad boy out.</div><div class="line">myhubot translate me from &lt;source&gt; into &lt;target&gt; &lt;phrase&gt; - Translates &lt;phrase&gt; from &lt;source&gt; into &lt;target&gt;. Both &lt;source&gt; and &lt;target&gt; are optional</div><div class="line">ship it - Display a motivation squirrel</div></pre></td></tr></table></figure>
<p>看到了吧！如果我们输入了特定的「输入」，机器人就会有反应啦！</p>
<p>当我们输入 <code>myhubot help</code> 的时候，返回的东东其实就是预定义的「输入」，这些预定义的「输入」只在 shell adapter 下有效哦！</p>
<h2 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter"></a>Adapter</h2><p>什么是 shell adapter ？ 我们运行 <code>./bin/hubot</code> 时默认的 adapter 就是 shell adapter。</p>
<p>什么是 adapter ？ 所谓的 adapter 其实是一些让机器人接收输入的接口。 </p>
<p>刚才提到，shell adapter 是默认情况下的 adapter，主要是用来测试 adapter 是否生效。说白了，其实就是没什么用！</p>
<p>觉得很坑爹是吧？说好的让我们的聊天软件整合我们的机器人呢？</p>
<p>实际上社区已经为我们提供了各种各样的 adapter，我们只要下载就可以用啦！具体请看看 <a href="https://hubot.github.com/docs/adapters/" target="_blank" rel="external">https://hubot.github.com/docs/adapters/</a></p>
<p>那么我们如何指定用某个 adapter 呢？很简单啦，只要启动机器人的时候带上 <code>-a</code> 参数就好了。<br>譬如如果我们想让机器人整合到 telegram，我们只要执行下面的命令就可以了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ npm install --save hubot-telegram</div><div class="line">$ ./bin/hubot -a telegram</div></pre></td></tr></table></figure>
<p>当然我们还需要设置一下，这些设置会根据不同的 adapter 而有所不同，具体请看对应的文档！</p>
<p>如果你所用的聊天软件并不在社区的支持列表中，又想把整合 Hubot 的话，可以自己写 adapter，文档在这里：<a href="https://hubot.github.com/docs/adapters/development/" target="_blank" rel="external">https://hubot.github.com/docs/adapters/development/</a></p>
<h2 id="Scripts"><a href="#Scripts" class="headerlink" title="Scripts"></a>Scripts</h2><p>我们一直说 Hubot 是聊天机器人，机器人最基本的是根据不同的「输入」给出不同的「输出」。<br>在 Hubot 应该怎么处理不同「输入」，给出不同的「输出」呢？<br>答案就是用 Scripts 啦！</p>
<p>有没有发现我们机器人的目录下有个 <code>scripts/</code> 文件夹？我们可以在这个文件夹下添加各种脚本文件，根据不同的「输入」给出不同的「输出」。<br>在我们启动 Hubot 的时候，它会加载 <code>scripts/</code> 文件夹下的脚本，赋予 Hubot 强大的交互能力！</p>
<p>需要注意的是，<code>scripts/</code> 下的脚本必须是 <code>.coffee</code> 或者 <code>.js</code> 格式的，而且必须暴露一个接受 robot 参数的函数！<br>我们还是先打开 <code>scripts/example.coffee</code> 看看吧！</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// coffee</span></div><div class="line"><span class="built_in">module</span>.exports = (robot) -&gt;</div><div class="line"></div><div class="line"><span class="comment">// js</span></div><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">robot</span>) </span>&#123;&#125;</div></pre></td></tr></table></figure>
<p>在这个函数里面，我们可以利用 <code>robot.hear</code>、<code>robot.response</code>、<code>robot.send</code>、<code>robot.reply</code> 等 api 为不同的「输入」给出不同的「输出」！<br>我们还可以用 <code>robot.http(url).get()</code> 等方法来发出 http 请求！这样我们的机器人就可以有更强大的交互能力了！</p>
<p>想知道更多 api 的用法的话，可以参考文档：<a href="https://hubot.github.com/docs/scripting/" target="_blank" rel="external">https://hubot.github.com/docs/scripting/</a></p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>Hubot 真的是一个简单易用的聊天机器人，我们可以把它整合到我们的聊天软件中，让那些简单但繁琐的任务自动化起来，提高我们的工作效率！<br>最后强烈推荐各位同学去读一下 Hubot 的源码，简单易懂，之后会对 Hubot 有更深刻的认识！</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://hubot.github.com/" target="_blank" rel="external">https://hubot.github.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Hubot 是 Github 的开源聊天机器人，可以用来做一些自动化任务，如部署网站，翻译语言等等。&lt;/p&gt;
&lt;p&gt;你可能会说，这些只要写个
    
    </summary>
    
      <category term="hubot" scheme="http://scarletsky.github.io/categories/hubot/"/>
    
    
      <category term="hubot" scheme="http://scarletsky.github.io/tags/hubot/"/>
    
  </entry>
  
  <entry>
    <title>Lodash 中 assign，extend 和 merge 的区别</title>
    <link href="http://scarletsky.github.io/2016/04/02/assign-vs-extend-vs-merge-in-lodash/"/>
    <id>http://scarletsky.github.io/2016/04/02/assign-vs-extend-vs-merge-in-lodash/</id>
    <published>2016-04-02T02:51:19.000Z</published>
    <updated>2016-04-02T05:17:35.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>我们经常在别人的代码中看见 <code>assign</code>，<code>extend</code>，<code>merge</code> 函数，这三个函数用起来很相似，都是合并源对象的属性到目标对象中。</p>
<p>既然都是合并对象，为什么还分三个不同的函数呢？它们之间到底有什么区别呢？</p>
<h2 id="assign-object-sources"><a href="#assign-object-sources" class="headerlink" title="assign(object, [sources])"></a>assign(object, [sources])</h2><p>我们先看看官方网站上面的定义：</p>
<blockquote>
<p>Assigns own enumerable string keyed properties of source objects to the destination object. Source objects are applied from left to right. Subsequent sources overwrite property assignments of previous sources.</p>
</blockquote>
<p>把源对象(sources)的属性分配到目标对象(object)，源对象会从左往右地调用，后面对象的属性会覆盖前面的。</p>
<p>看看下面的例子:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">assign(&#123;&#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;);</div><div class="line"><span class="comment">// &#123; a: 1, b: 2 &#125;</span></div><div class="line"></div><div class="line"><span class="comment">// 后面的 &#123; a: 2 &#125; 把前面的 &#123; a: 1 &#125; 覆盖了</span></div><div class="line">assign(&#123;&#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">2</span> &#125;);</div><div class="line"><span class="comment">// &#123; a: 2, b: 2 &#125;</span></div><div class="line"></div><div class="line"><span class="comment">// 观察下面两个例子，如果属性值为 object，后面的值会覆盖前面的值</span></div><div class="line">assign(</div><div class="line">  &#123;&#125;,</div><div class="line">  &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;,</div><div class="line">  &#123; <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">2</span>, <span class="attr">d</span>: <span class="number">3</span> &#125; &#125;</div><div class="line">)</div><div class="line"><span class="comment">// &#123; a: 1, b: &#123; c: 2, d: 3 &#125; &#125;</span></div><div class="line"></div><div class="line">assign(</div><div class="line">  &#123;&#125;,</div><div class="line">  &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;,</div><div class="line">  &#123; <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">2</span>, <span class="attr">d</span>: <span class="number">3</span> &#125; &#125;,</div><div class="line">  &#123; <span class="attr">b</span>: &#123; <span class="attr">e</span>: <span class="number">4</span> &#125; &#125;</div><div class="line">)</div><div class="line"><span class="comment">// &#123; a: 1, b: &#123; e: 4 &#125; &#125;</span></div><div class="line"></div><div class="line"><span class="comment">// `assign` 函数会忽略原型链上的属性。</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123; <span class="keyword">this</span>.c = <span class="number">3</span>; &#125;</div><div class="line">Foo.prototype.d = <span class="number">4</span>;</div><div class="line">assign(&#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, <span class="keyword">new</span> Foo());</div><div class="line"><span class="comment">// &#123; a: 1, c: 3 &#125;</span></div><div class="line"></div><div class="line"><span class="comment">// `assign` 会修改原来的对象</span></div><div class="line"><span class="keyword">var</span> test = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</div><div class="line">assign(test, &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;); <span class="comment">// &#123; a: 1, b: 2 &#125;</span></div><div class="line"><span class="built_in">console</span>.log(test);      <span class="comment">// &#123; a: 1, b: 2 &#125;</span></div></pre></td></tr></table></figure>
<h2 id="extend-object-sources"><a href="#extend-object-sources" class="headerlink" title="extend(object, [sources])"></a>extend(object, [sources])</h2><p>在 3.x 版本中，<code>extend</code> 是 <code>assign</code> 的别名，它们的作用是一模一样的。<br>在 4.x 版本中，<code>extend</code> 是 <code>assignIn</code> 的别名，和 <code>assign</code> 有点区别。</p>
<p>官方定义如下：</p>
<blockquote>
<p>This method is like _.assign except that it iterates over own and inherited source properties.</p>
</blockquote>
<p>在上面的例子中，我们知道 <code>assign</code> 函数不会把原型链上的属性合并到目标对象，而 <code>extend</code> 或 <code>assignIn</code> 函数则会！</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Important !! this is Lodash 4.x !!</span></div><div class="line"></div><div class="line"><span class="comment">// 把源对象原型链上的属性也合并到目标对象上！</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123; <span class="keyword">this</span>.c = <span class="number">3</span>; &#125;</div><div class="line">Foo.prototype.d = <span class="number">4</span>;</div><div class="line">extend(&#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, <span class="keyword">new</span> Foo());</div><div class="line"><span class="comment">// &#123; a: 1, c: 3, d: 4 &#125;</span></div></pre></td></tr></table></figure>
<h2 id="merge-object-sources"><a href="#merge-object-sources" class="headerlink" title="merge(object, [sources])"></a>merge(object, [sources])</h2><p>我们看看 <code>merge</code> 函数的定义：</p>
<blockquote>
<p>This method is like _.assign except that it recursively merges own and inherited enumerable string keyed properties of source objects into the destination object. Source properties that resolve to undefined are skipped if a destination value exists. Array and plain object properties are merged recursively.Other objects and value types are overridden by assignment. Source objects are applied from left to right. Subsequent sources overwrite property assignments of previous sources.</p>
</blockquote>
<p><code>merge</code> 也和 <code>assign</code> 类似，不同的地方在于 <code>merge</code> 遇到相同属性的时候，如果属性值为纯对象(plain object)或者集合(collection)时，不是用后面的属性值去覆盖前面的属性值，而是会把前后两个属性值合并。<br>如果源对象的属性值为 <code>undefined</code>，则会忽略该属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">assign(</div><div class="line">  &#123;&#125;,</div><div class="line">  &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;,</div><div class="line">  &#123; <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">2</span>, <span class="attr">d</span>: <span class="number">3</span>&#125; &#125;,</div><div class="line">  &#123; <span class="attr">b</span>: &#123; <span class="attr">e</span>: <span class="number">4</span> &#125; &#125;</div><div class="line">)</div><div class="line"><span class="comment">// &#123; a: 1, b: &#123; e: 4 &#125; &#125;</span></div><div class="line">merge(</div><div class="line">  &#123;&#125;,</div><div class="line">  &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;,</div><div class="line">  &#123; <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">2</span>, <span class="attr">d</span>: <span class="number">3</span>&#125; &#125;,</div><div class="line">  &#123; <span class="attr">b</span>: &#123; <span class="attr">e</span>: <span class="number">4</span> &#125; &#125;</div><div class="line">)</div><div class="line"><span class="comment">// &#123; a: 1, b: &#123; c: 2, d: 3, e: 4 &#125; &#125;</span></div><div class="line"></div><div class="line"><span class="comment">// 合并集合</span></div><div class="line"><span class="keyword">var</span> users = &#123;</div><div class="line">  <span class="string">'data'</span>: [&#123; <span class="string">'user'</span>: <span class="string">'barney'</span> &#125;, &#123; <span class="string">'user'</span>: <span class="string">'fred'</span> &#125;]</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> ages = &#123;</div><div class="line">  <span class="string">'data'</span>: [&#123; <span class="string">'age'</span>: <span class="number">36</span> &#125;, &#123; <span class="string">'age'</span>: <span class="number">40</span> &#125;]</div><div class="line">&#125;;</div><div class="line">merge(&#123;&#125;, users, ages)</div><div class="line"><span class="comment">// &#123; data: [ &#123; user: 'barney', age: 36 &#125;, &#123; user: 'fred', age: 40 &#125; ] &#125;</span></div><div class="line"></div><div class="line"><span class="comment">// merge 函数会修改原来的对象！</span></div><div class="line">merge(users, ages)</div><div class="line"><span class="built_in">console</span>.log(users) <span class="comment">// &#123; data: [ &#123; user: 'barney', age: 36 &#125;, &#123; user: 'fred', age: 40 &#125; ]</span></div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="相同之处"><a href="#相同之处" class="headerlink" title="相同之处"></a>相同之处</h3><ul>
<li>都可以用来合并对象</li>
<li>都会修改原来的对象 (如果原来的对象是作为函数的第一个参数的话)</li>
</ul>
<h3 id="不同之处"><a href="#不同之处" class="headerlink" title="不同之处"></a>不同之处</h3><ul>
<li><p><code>assign</code> 函数不会处理原型链上的属性，也不会合并相同的属性，而是用后面的属性值覆盖前面的属性值</p>
</li>
<li><p><code>extend</code></p>
<ul>
<li>3.x 版本中和 <code>assign</code> 一样</li>
<li>4.x 版本中会合并原型链上的属性</li>
</ul>
</li>
<li><p><code>merge</code> 遇到相同属性名的时候，如果属性值是纯对象或集合的时候，会合并属性值</p>
</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://lodash.com/docs" target="_blank" rel="external">https://lodash.com/docs</a><br><a href="http://stackoverflow.com/questions/19965844/lodash-difference-between-extend-assign-and-merge" target="_blank" rel="external">http://stackoverflow.com/questions/19965844/lodash-difference-between-extend-assign-and-merge</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;我们经常在别人的代码中看见 &lt;code&gt;assign&lt;/code&gt;，&lt;code&gt;extend&lt;/code&gt;，&lt;code&gt;merge&lt;/cod
    
    </summary>
    
      <category term="javascript" scheme="http://scarletsky.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://scarletsky.github.io/tags/javascript/"/>
    
  </entry>
  
</feed>
